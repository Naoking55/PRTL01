<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>テロップエディタ v1.3</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Yu Gothic UI', sans-serif; background: #2b2b2b; color: #ccc; display: flex; height: 100vh; }
        .sidebar { width: 300px; background: #383838; padding: 15px; overflow-y: auto; }
        .sidebar h3 { color: #fff; margin: 10px 0; font-size: 14px; }
        .sidebar label { display: block; margin: 8px 0 4px; font-size: 12px; }
        .sidebar input, .sidebar select { width: 100%; padding: 6px; background: #4a4a4a; border: 1px solid #555; color: #fff; border-radius: 3px; font-size: 12px; }
        .sidebar input[type="color"] { height: 30px; padding: 2px; cursor: pointer; }
        .sidebar input[type="range"] { padding: 0; }
        .btn { width: 100%; padding: 8px; margin: 5px 0; cursor: pointer; border: none; border-radius: 3px; font-size: 12px; }
        .btn-primary { background: #0078d4; color: #fff; }
        .btn-secondary { background: #4a4a4a; color: #fff; }
        .btn-danger { background: #d43; color: #fff; }
        .btn:hover { opacity: 0.9; }
        .layer-list { background: #2b2b2b; border-radius: 3px; max-height: 120px; overflow-y: auto; }
        .layer-item { padding: 6px 8px; cursor: pointer; border-bottom: 1px solid #444; font-size: 11px; }
        .layer-item:hover { background: #4a4a4a; }
        .layer-item.selected { background: #0078d4; color: #fff; }
        .main { flex: 1; display: flex; flex-direction: column; padding: 15px; min-width: 0; }
        .toolbar { display: flex; gap: 10px; margin-bottom: 10px; align-items: center; flex-shrink: 0; }
        .canvas-container { flex: 1; display: flex; align-items: center; justify-content: center; background: #1a1a1a; border-radius: 5px; overflow: hidden; position: relative; min-height: 0; }
        #canvas { background: repeating-conic-gradient(#3a3a3a 0% 25%, #2a2a2a 0% 50%) 50% / 20px 20px; cursor: text; max-width: 100%; max-height: 100%; }
        .status { padding: 8px; background: #383838; font-size: 11px; display: flex; justify-content: space-between; flex-shrink: 0; }
        .char-info { font-size: 10px; color: #888; margin-top: 5px; }
    </style>
</head>
<body>
    <div class="sidebar">
        <h3>レイヤー</h3>
        <div class="layer-list" id="layerList"></div>
        <button class="btn btn-danger" onclick="deleteSelected()">選択を削除</button>

        <h3>文字スタイル</h3>
        <div class="char-info" id="charInfo">文字を選択してください</div>

        <label>フォント</label>
        <select id="fontFamily" onchange="applyStyle()">
            <option value="Yu Gothic UI">Yu Gothic UI</option>
            <option value="Meiryo">メイリオ</option>
            <option value="MS Gothic">MS ゴシック</option>
            <option value="Arial">Arial</option>
            <option value="Impact">Impact</option>
        </select>

        <label>サイズ: <span id="fontSizeVal">72</span>px</label>
        <input type="range" id="fontSize" min="12" max="200" value="72" oninput="document.getElementById('fontSizeVal').textContent=this.value;applyStyle()">

        <label>文字色</label>
        <input type="color" id="textColor" value="#ffffff" onchange="applyStyle()">

        <h3>縁取り</h3>
        <label><input type="checkbox" id="strokeEnabled" checked onchange="applyStyle()"> 有効</label>
        <label>色</label>
        <input type="color" id="strokeColor" value="#000000" onchange="applyStyle()">
        <label>太さ: <span id="strokeWidthVal">4</span>px</label>
        <input type="range" id="strokeWidth" min="0" max="20" value="4" oninput="document.getElementById('strokeWidthVal').textContent=this.value;applyStyle()">

        <h3>出力</h3>
        <button class="btn btn-primary" onclick="exportPNG()">PNG書き出し</button>
        <button class="btn btn-secondary" onclick="saveProject()">プロジェクト保存</button>
        <button class="btn btn-secondary" onclick="loadProject()">プロジェクト読込</button>
    </div>

    <div class="main">
        <div class="toolbar">
            <select id="resolution" onchange="changeResolution()">
                <option value="1920x1080">1920×1080 (HD)</option>
                <option value="3840x2160">3840×2160 (4K)</option>
            </select>
            <span style="font-size:11px;color:#888;">クリック:テキスト追加 / ダブルクリック:文字選択 / ドラッグ:移動</span>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="1920" height="1080"></canvas>
        </div>
        <div class="status">
            <span id="statusText">準備完了</span>
            <span id="resolution-display">1920×1080</span>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad(event)">

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        let textObjects = []; // { id, x, y, chars: [{char, fontSize, fontFamily, color, strokeEnabled, strokeColor, strokeWidth}] }
        let selectedObjId = null;
        let selectedCharStart = -1;
        let selectedCharEnd = -1;
        let isDragging = false;
        let isSelecting = false;
        let dragOffset = { x: 0, y: 0 };
        let scale = 1;
        let editingObjId = null;
        let cursorPos = 0;
        let cursorVisible = true;
        let cursorInterval = null;

        // デフォルトスタイル取得
        function getDefaultStyle() {
            return {
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontFamily: document.getElementById('fontFamily').value,
                color: document.getElementById('textColor').value,
                strokeEnabled: document.getElementById('strokeEnabled').checked,
                strokeColor: document.getElementById('strokeColor').value,
                strokeWidth: parseInt(document.getElementById('strokeWidth').value)
            };
        }

        // マウスダウン
        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            const obj = findObjectAt(x, y);

            if (editingObjId) {
                // 編集中：文字選択開始
                if (obj && obj.id === editingObjId) {
                    const charIdx = getCharIndexAt(obj, x, y);
                    selectedCharStart = charIdx;
                    selectedCharEnd = charIdx;
                    cursorPos = charIdx;
                    isSelecting = true;
                    render();
                } else {
                    // 編集終了
                    exitEditMode();
                    if (obj) {
                        selectObject(obj.id);
                        isDragging = true;
                        dragOffset = { x: x - obj.x, y: y - obj.y };
                    }
                }
            } else if (obj) {
                selectObject(obj.id);
                isDragging = true;
                dragOffset = { x: x - obj.x, y: y - obj.y };
            }
        });

        // ダブルクリック
        canvas.addEventListener('dblclick', (e) => {
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            const obj = findObjectAt(x, y);
            if (obj) {
                enterEditMode(obj.id);
                const charIdx = getCharIndexAt(obj, x, y);
                cursorPos = charIdx;
                selectedCharStart = -1;
                selectedCharEnd = -1;
                render();
            } else {
                // 新規テキスト
                const text = prompt('テキストを入力:');
                if (text) {
                    createTextObject(text, x, y);
                }
            }
        });

        // マウス移動
        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (isSelecting && editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (obj) {
                    selectedCharEnd = getCharIndexAt(obj, x, y);
                    render();
                }
            } else if (isDragging && selectedObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    obj.x = x - dragOffset.x;
                    obj.y = y - dragOffset.y;
                    render();
                }
            }
        });

        // マウスアップ
        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isSelecting = false;
            updateCharInfo();
        });

        // キー入力
        document.addEventListener('keydown', (e) => {
            if (!editingObjId) return;
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const start = Math.min(selectedCharStart, selectedCharEnd);
                    const end = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(start, end - start);
                    cursorPos = start;
                    selectedCharStart = -1;
                    selectedCharEnd = -1;
                } else if (cursorPos > 0) {
                    obj.chars.splice(cursorPos - 1, 1);
                    cursorPos--;
                }
                render();
            } else if (e.key === 'Delete') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const start = Math.min(selectedCharStart, selectedCharEnd);
                    const end = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(start, end - start);
                    cursorPos = start;
                    selectedCharStart = -1;
                    selectedCharEnd = -1;
                } else if (cursorPos < obj.chars.length) {
                    obj.chars.splice(cursorPos, 1);
                }
                render();
            } else if (e.key === 'ArrowLeft') {
                if (cursorPos > 0) cursorPos--;
                selectedCharStart = -1;
                render();
            } else if (e.key === 'ArrowRight') {
                if (cursorPos < obj.chars.length) cursorPos++;
                selectedCharStart = -1;
                render();
            } else if (e.key === 'Escape') {
                exitEditMode();
            } else if (e.key === 'a' && e.ctrlKey) {
                e.preventDefault();
                selectedCharStart = 0;
                selectedCharEnd = obj.chars.length;
                render();
                updateCharInfo();
            } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const start = Math.min(selectedCharStart, selectedCharEnd);
                    const end = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(start, end - start);
                    cursorPos = start;
                    selectedCharStart = -1;
                    selectedCharEnd = -1;
                }
                const style = getDefaultStyle();
                obj.chars.splice(cursorPos, 0, { char: e.key, ...style });
                cursorPos++;
                render();
            }
            updateLayerList();
        });

        // 文字インデックス取得
        function getCharIndexAt(obj, x, y) {
            let posX = obj.x;
            for (let i = 0; i < obj.chars.length; i++) {
                const c = obj.chars[i];
                ctx.font = `bold ${c.fontSize}px "${c.fontFamily}"`;
                const w = ctx.measureText(c.char).width;
                if (x < posX + w / 2) return i;
                posX += w;
            }
            return obj.chars.length;
        }

        // テキストオブジェクト作成
        function createTextObject(text, x, y) {
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));
            const obj = { id: Date.now(), x, y, chars };
            textObjects.push(obj);
            selectObject(obj.id);
            updateLayerList();
            render();
        }

        // オブジェクト検索
        function findObjectAt(x, y) {
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i];
                const bounds = getObjectBounds(obj);
                if (x >= bounds.x - 10 && x <= bounds.x + bounds.w + 10 &&
                    y >= bounds.y - 10 && y <= bounds.y + bounds.h + 10) {
                    return obj;
                }
            }
            return null;
        }

        // オブジェクト境界取得
        function getObjectBounds(obj) {
            let w = 0, maxSize = 0;
            obj.chars.forEach(c => {
                ctx.font = `bold ${c.fontSize}px "${c.fontFamily}"`;
                w += ctx.measureText(c.char).width;
                if (c.fontSize > maxSize) maxSize = c.fontSize;
            });
            return { x: obj.x, y: obj.y - maxSize / 2, w, h: maxSize };
        }

        // オブジェクト選択
        function selectObject(id) {
            selectedObjId = id;
            updateLayerList();
            render();
        }

        // 編集モード開始
        function enterEditMode(id) {
            editingObjId = id;
            selectedObjId = id;
            cursorPos = 0;
            cursorVisible = true;
            if (cursorInterval) clearInterval(cursorInterval);
            cursorInterval = setInterval(() => { cursorVisible = !cursorVisible; render(); }, 500);
            updateLayerList();
        }

        // 編集モード終了
        function exitEditMode() {
            editingObjId = null;
            selectedCharStart = -1;
            selectedCharEnd = -1;
            if (cursorInterval) clearInterval(cursorInterval);
            render();
        }

        // スタイル適用
        function applyStyle() {
            if (!editingObjId) return;
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;

            if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                const start = Math.min(selectedCharStart, selectedCharEnd);
                const end = Math.max(selectedCharStart, selectedCharEnd);
                const style = getDefaultStyle();
                for (let i = start; i < end; i++) {
                    Object.assign(obj.chars[i], style);
                }
                render();
            }
        }

        // 選択文字情報更新
        function updateCharInfo() {
            const info = document.getElementById('charInfo');
            if (editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                const count = Math.abs(selectedCharEnd - selectedCharStart);
                info.textContent = `${count}文字選択中`;
            } else {
                info.textContent = '文字を選択してください';
            }
        }

        // 選択削除
        function deleteSelected() {
            if (!selectedObjId) return;
            textObjects = textObjects.filter(o => o.id !== selectedObjId);
            selectedObjId = null;
            editingObjId = null;
            updateLayerList();
            render();
        }

        // レイヤーリスト更新
        function updateLayerList() {
            const list = document.getElementById('layerList');
            list.innerHTML = '';
            textObjects.slice().reverse().forEach(obj => {
                const div = document.createElement('div');
                div.className = 'layer-item' + (obj.id === selectedObjId ? ' selected' : '');
                const text = obj.chars.map(c => c.char).join('');
                div.textContent = text.substring(0, 15) + (text.length > 15 ? '...' : '');
                div.onclick = () => { exitEditMode(); selectObject(obj.id); };
                div.ondblclick = () => enterEditMode(obj.id);
                list.appendChild(div);
            });
        }

        // 描画
        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            textObjects.forEach(obj => {
                let posX = obj.x;
                let maxSize = Math.max(...obj.chars.map(c => c.fontSize), 72);

                // 選択範囲ハイライト
                if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const start = Math.min(selectedCharStart, selectedCharEnd);
                    const end = Math.max(selectedCharStart, selectedCharEnd);
                    let hlX = obj.x;
                    for (let i = 0; i < start; i++) {
                        ctx.font = `bold ${obj.chars[i].fontSize}px "${obj.chars[i].fontFamily}"`;
                        hlX += ctx.measureText(obj.chars[i].char).width;
                    }
                    let hlW = 0;
                    for (let i = start; i < end; i++) {
                        ctx.font = `bold ${obj.chars[i].fontSize}px "${obj.chars[i].fontFamily}"`;
                        hlW += ctx.measureText(obj.chars[i].char).width;
                    }
                    ctx.fillStyle = 'rgba(0,120,212,0.3)';
                    ctx.fillRect(hlX, obj.y - maxSize / 2, hlW, maxSize);
                }

                // 文字描画
                obj.chars.forEach((c, i) => {
                    ctx.font = `bold ${c.fontSize}px "${c.fontFamily}"`;
                    ctx.textBaseline = 'middle';
                    const w = ctx.measureText(c.char).width;

                    if (c.strokeEnabled) {
                        ctx.strokeStyle = c.strokeColor;
                        ctx.lineWidth = c.strokeWidth * 2;
                        ctx.lineJoin = 'round';
                        ctx.strokeText(c.char, posX, obj.y);
                    }
                    ctx.fillStyle = c.color;
                    ctx.fillText(c.char, posX, obj.y);
                    posX += w;
                });

                // カーソル
                if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                    let cX = obj.x;
                    for (let i = 0; i < cursorPos; i++) {
                        ctx.font = `bold ${obj.chars[i].fontSize}px "${obj.chars[i].fontFamily}"`;
                        cX += ctx.measureText(obj.chars[i].char).width;
                    }
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(cX, obj.y - maxSize / 2);
                    ctx.lineTo(cX, obj.y + maxSize / 2);
                    ctx.stroke();
                }

                // 選択枠
                if (obj.id === selectedObjId && obj.id !== editingObjId) {
                    const bounds = getObjectBounds(obj);
                    ctx.strokeStyle = '#0078d4';
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 3]);
                    ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.w + 10, bounds.h + 10);
                    ctx.setLineDash([]);
                }
            });

            document.getElementById('statusText').textContent = editingObjId ? '編集中 (Escで終了)' : `オブジェクト: ${textObjects.length}`;
        }

        function changeResolution() {
            const [w, h] = document.getElementById('resolution').value.split('x').map(Number);
            canvas.width = w; canvas.height = h;
            document.getElementById('resolution-display').textContent = `${w}×${h}`;
            render();
        }

        function exportPNG() {
            exitEditMode(); selectedObjId = null; render();
            const link = document.createElement('a');
            link.download = `telop_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function saveProject() {
            const project = { version: '1.3', resolution: document.getElementById('resolution').value, objects: textObjects };
            const blob = new Blob([JSON.stringify(project)], {type: 'application/json'});
            const link = document.createElement('a');
            link.download = `telop_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function loadProject() { document.getElementById('fileInput').click(); }

        function handleFileLoad(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const p = JSON.parse(ev.target.result);
                    if (p.resolution) { document.getElementById('resolution').value = p.resolution; changeResolution(); }
                    textObjects = p.objects || [];
                    selectedObjId = null; editingObjId = null;
                    updateLayerList(); render();
                } catch { alert('読込失敗'); }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        render();
    </script>
</body>
</html>
