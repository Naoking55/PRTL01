<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>テロップエディタ v3.0</title>
    <style>
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: 'Segoe UI', 'Yu Gothic UI', sans-serif; background: #1e1e1e; color: #e0e0e0; display: flex; height: 100vh; }

        /* Sidebar styles */
        .sidebar { width: 340px; background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%); padding: 12px; overflow-y: auto; border-right: 1px solid #3a3a3a; }
        .sidebar h3 { color: #fff; margin: 12px 0 8px; font-size: 12px; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; }
        .sidebar h4 { color: #8a8a8a; margin: 8px 0 4px; font-size: 10px; font-weight: 500; }
        .sidebar label { display: block; margin: 5px 0 2px; font-size: 10px; color: #aaa; }
        .sidebar input, .sidebar select {
            width: 100%; padding: 6px 8px;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #fff;
            border-radius: 4px;
            font-size: 11px;
            transition: border-color 0.2s, background 0.2s;
        }

        /* Right sidebar for canvas thumbnails */
        .right-sidebar {
            width: 180px;
            background: linear-gradient(180deg, #2d2d2d 0%, #252525 100%);
            padding: 8px;
            overflow-y: auto;
            border-left: 1px solid #3a3a3a;
            display: flex;
            flex-direction: column;
        }
        .right-sidebar h3 {
            color: #fff;
            margin: 4px 0 8px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .canvas-list {
            flex: 1;
            overflow-y: auto;
        }
        .canvas-thumb {
            position: relative;
            margin-bottom: 8px;
            border: 2px solid transparent;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .canvas-thumb:hover {
            border-color: #4a4a4a;
        }
        .canvas-thumb.active {
            border-color: #0078d4;
        }
        .canvas-thumb img {
            width: 100%;
            display: block;
            border-radius: 2px;
            background: #1a1a1a;
        }
        .canvas-thumb-name {
            font-size: 9px;
            color: #aaa;
            padding: 4px;
            text-align: center;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .canvas-thumb-actions {
            position: absolute;
            top: 2px;
            right: 2px;
            display: none;
            gap: 2px;
        }
        .canvas-thumb:hover .canvas-thumb-actions {
            display: flex;
        }
        .canvas-thumb-btn {
            width: 18px;
            height: 18px;
            background: rgba(0,0,0,0.7);
            border: none;
            border-radius: 3px;
            color: #fff;
            font-size: 10px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .canvas-thumb-btn:hover {
            background: #0078d4;
        }
        .canvas-actions {
            display: flex;
            gap: 4px;
            margin-bottom: 8px;
        }
        .canvas-actions .btn {
            flex: 1;
            padding: 6px 4px;
            font-size: 10px;
        }
        .sidebar input:focus, .sidebar select:focus {
            outline: none;
            border-color: #0078d4;
            background: #404040;
        }
        .sidebar input[type="color"] { height: 28px; padding: 3px; cursor: pointer; }
        .sidebar input[type="range"] { padding: 0; accent-color: #0078d4; }
        .sidebar input[type="checkbox"] { width: auto; margin-right: 6px; accent-color: #0078d4; }

        /* Buttons */
        .btn {
            width: 100%; padding: 8px 12px; margin: 3px 0;
            cursor: pointer; border: none; border-radius: 4px;
            font-size: 11px; font-weight: 500;
            transition: all 0.2s;
        }
        .btn-primary { background: linear-gradient(180deg, #0084e8 0%, #0068b8 100%); color: #fff; }
        .btn-primary:hover { background: linear-gradient(180deg, #0094f8 0%, #0078d4 100%); }
        .btn-secondary { background: #4a4a4a; color: #fff; }
        .btn-secondary:hover { background: #555; }
        .btn-danger { background: #c42b1c; color: #fff; }
        .btn-danger:hover { background: #d43; }
        .btn-small { width: auto; padding: 4px 8px; margin: 2px; font-size: 10px; }

        /* Layer list */
        .layer-list { background: #1a1a1a; border-radius: 4px; max-height: 80px; overflow-y: auto; border: 1px solid #3a3a3a; }
        .layer-item { padding: 6px 10px; cursor: pointer; border-bottom: 1px solid #2a2a2a; font-size: 10px; transition: background 0.15s; }
        .layer-item:hover { background: #3a3a3a; }
        .layer-item.selected { background: #0078d4; color: #fff; }

        /* Align buttons */
        .align-buttons { display: flex; gap: 2px; margin: 4px 0; }
        .align-btn {
            flex: 1; padding: 6px;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #aaa;
            cursor: pointer;
            font-size: 10px;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .align-btn:hover { background: #4a4a4a; color: #fff; }
        .align-btn.active { background: #0078d4; color: #fff; border-color: #0078d4; }

        /* Main area */
        .main { flex: 1; display: flex; flex-direction: column; padding: 0; min-width: 0; background: #1a1a1a; }
        .toolbar {
            display: flex; gap: 8px; padding: 8px 12px;
            align-items: center; flex-shrink: 0;
            background: #2d2d2d;
            border-bottom: 1px solid #3a3a3a;
        }
        .toolbar select {
            padding: 5px 8px;
            background: #3a3a3a;
            border: 1px solid #4a4a4a;
            color: #fff;
            border-radius: 4px;
            font-size: 11px;
        }

        /* Canvas container */
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #141414;
            overflow: hidden;
            position: relative;
            min-height: 0;
        }
        #canvas {
            background: repeating-conic-gradient(#2a2a2a 0% 25%, #1e1e1e 0% 50%) 50% / 16px 16px;
            max-width: 100%;
            max-height: 100%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.5);
        }

        /* Bottom toolbar */
        .bottom-toolbar {
            display: flex;
            padding: 6px 12px;
            background: #2d2d2d;
            border-top: 1px solid #3a3a3a;
            gap: 2px;
            flex-shrink: 0;
        }
        .tool-group {
            display: flex;
            gap: 1px;
            padding: 0 8px;
            border-right: 1px solid #3a3a3a;
        }
        .tool-group:last-child { border-right: none; }
        .tool-icon {
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            color: #aaa;
            transition: all 0.15s;
        }
        .tool-icon:hover { background: #3a3a3a; color: #fff; }
        .tool-icon.active { background: #0078d4; color: #fff; border-color: #0078d4; }
        .tool-icon svg { width: 16px; height: 16px; fill: currentColor; }
        .tool-icon span { font-size: 11px; font-weight: bold; }

        /* Status bar */
        .status {
            padding: 6px 12px;
            background: #252525;
            font-size: 10px;
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
            color: #888;
            border-top: 1px solid #3a3a3a;
        }

        /* Property sections */
        .char-info { font-size: 9px; color: #666; margin-top: 4px; }
        .prop-section { background: #1a1a1a; padding: 8px; border-radius: 4px; margin: 6px 0; border: 1px solid #2a2a2a; }
        .prop-row { display: flex; gap: 6px; align-items: center; margin: 3px 0; }
        .prop-label { font-size: 10px; width: 50px; color: #888; }
        .prop-input { flex: 1; }
        .prop-input input { width: 100%; }
        .row2 { display: flex; gap: 4px; }
        .row2 > div { flex: 1; }
        .row2 label { font-size: 9px; }
        .row3 { display: flex; gap: 4px; }
        .row3 > div { flex: 1; }
        .row3 label { font-size: 9px; }

        /* Collapsible sections */
        .collapsible { cursor: pointer; user-select: none; }
        .collapsible::before { content: '▼ '; font-size: 8px; color: #666; }
        .collapsible.collapsed::before { content: '▶ '; }
        .collapse-content { display: block; }
        .collapse-content.hidden { display: none; }

        /* Other elements */
        #imeInput { position: fixed; top: 0; left: 0; width: 1px; height: 1px; opacity: 0.01; border: none; outline: none; background: transparent; }
        .stroke-item { background: #2a2a2a; padding: 8px; margin: 4px 0; border-radius: 4px; border: 1px solid #3a3a3a; }
        .stroke-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 4px; }
        .gradient-stop { position: relative; padding-right: 24px; }
        .gradient-stop .remove-stop {
            position: absolute; right: 0; top: 50%; transform: translateY(-50%);
            background: #c42b1c; color: #fff; border: none; border-radius: 3px;
            width: 18px; height: 18px; font-size: 11px; cursor: pointer; display: none;
        }
        .gradient-stop:nth-child(n+3) .remove-stop { display: block; }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #1a1a1a; }
        ::-webkit-scrollbar-thumb { background: #4a4a4a; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #5a5a5a; }
    </style>
</head>
<body>
    <div class="sidebar">
        <h3 class="collapsible" onclick="toggleCollapse(this)">キャンバス設定</h3>
        <div class="collapse-content">
            <label>背景色</label>
            <div class="row2">
                <div><input type="color" id="canvasBgColor" value="#000000" onchange="updateCanvasBackground()"></div>
                <div><label>不透明度%</label><input type="number" id="canvasBgOpacity" min="0" max="100" value="0" onchange="updateCanvasBackground()"></div>
            </div>

            <label>背景画像</label>
            <input type="file" id="bgImageInput" accept="image/*" onchange="loadBackgroundImage(event)" style="width:100%;font-size:11px;">
            <div class="row2" style="margin-top:5px;">
                <div><button class="btn btn-small btn-secondary" onclick="clearBackgroundImage()">画像クリア</button></div>
                <div><label>フィット</label><select id="bgImageFit" onchange="render()" style="font-size:11px;">
                    <option value="contain">contain</option>
                    <option value="cover">cover</option>
                    <option value="stretch">stretch</option>
                </select></div>
            </div>

            <h4>セーフマージン</h4>
            <label><input type="checkbox" id="safeMarginEnabled" checked onchange="render()"> 表示</label>
            <div class="row2">
                <div><label>アクション%</label><input type="number" id="actionSafeMargin" min="0" max="20" value="5" onchange="render()"></div>
                <div><label>タイトル%</label><input type="number" id="titleSafeMargin" min="0" max="20" value="10" onchange="render()"></div>
            </div>
            <div class="row2">
                <div><label>色</label><input type="color" id="safeMarginColor" value="#ffffff" onchange="render()"></div>
                <div><label>不透明度%</label><input type="number" id="safeMarginOpacity" min="0" max="100" value="50" onchange="render()"></div>
            </div>
        </div>

        <h3>レイヤー</h3>
        <div class="layer-list" id="layerList"></div>
        <div style="display:flex;gap:3px;margin-top:6px;">
            <button class="btn btn-small btn-secondary" onclick="moveLayerUp()">↑</button>
            <button class="btn btn-small btn-secondary" onclick="moveLayerDown()">↓</button>
            <button class="btn btn-small btn-secondary" onclick="alignToCenter('h')">たて中央</button>
            <button class="btn btn-small btn-secondary" onclick="alignToCenter('v')">よこ中央</button>
            <button class="btn btn-small btn-danger" onclick="deleteSelected()">削除</button>
        </div>

        <div class="prop-section" id="layerProps" style="display:none;">
            <div class="row2">
                <div><label>名前</label><input type="text" id="layerName" onchange="updateLayerName()"></div>
            </div>
            <div class="row2">
                <div><label>X</label><input type="number" id="layerX" step="0.1" onchange="updateLayerPosition()"></div>
                <div><label>Y</label><input type="number" id="layerY" step="0.1" onchange="updateLayerPosition()"></div>
            </div>
            <div class="row2">
                <div><label>幅</label><input type="number" id="layerWidth" step="0.1" onchange="updateLayerSize()"></div>
                <div><label>高さ</label><input type="number" id="layerHeight" step="0.1" onchange="updateLayerSize()"></div>
            </div>
            <div class="row2">
                <div><label>回転°</label><input type="number" id="layerRotation" step="0.1" value="0" onchange="updateLayerRotation()"></div>
                <div><label>行間</label><input type="number" id="layerLineHeight" step="0.1" value="1.2" onchange="updateLayerLineHeight()"></div>
            </div>
            <div class="prop-row">
                <span class="prop-label">不透明度</span>
                <input type="range" id="layerOpacity" min="0" max="100" value="100" oninput="updateLayerOpacity()"><span id="opacityVal">100</span>%
            </div>
        </div>

        <h3 class="collapsible" onclick="toggleCollapse(this)">文字スタイル</h3>
        <div class="collapse-content">
            <div class="char-info" id="charInfo">文字を選択してください</div>

            <label>フォント</label>
            <select id="fontFamily" onchange="handleFontChange()" style="width: 100%;">
                <optgroup label="日本語フォント">
                    <option value="Yu Gothic UI">Yu Gothic UI</option>
                    <option value="Meiryo">メイリオ</option>
                    <option value="MS Gothic">MS ゴシック</option>
                    <option value="Hiragino Sans">ヒラギノ角ゴ</option>
                    <option value="Noto Sans JP">Noto Sans JP</option>
                </optgroup>
                <optgroup label="欧文フォント">
                    <option value="Arial">Arial</option>
                    <option value="Impact">Impact</option>
                    <option value="Helvetica">Helvetica</option>
                    <option value="Times New Roman">Times New Roman</option>
                    <option value="Georgia">Georgia</option>
                </optgroup>
                <optgroup label="デザインフォント">
                    <option value="Comic Sans MS">Comic Sans MS</option>
                    <option value="Courier New">Courier New</option>
                </optgroup>
                <optgroup id="systemFontsGroup" label="システムフォント" style="display:none;">
                </optgroup>
                <optgroup label="カスタム">
                    <option value="__custom__">カスタムフォント...</option>
                </optgroup>
            </select>
            <input type="text" id="customFontInput" placeholder="フォント名を入力" style="display:none; margin-top:5px;" onchange="applyCustomFont()">

            <div class="row2">
                <div><label>サイズ</label><input type="number" id="fontSize" min="1" value="72" onchange="applyStyle()"></div>
                <div><label>縦横比%</label><input type="number" id="charScaleX" min="10" max="400" value="100" onchange="applyStyle()"></div>
            </div>

            <div class="row2">
                <div><label>カーニング</label><input type="number" id="charKerning" step="1" value="0" onchange="applyStyle()"></div>
                <div><label>トラッキング</label><input type="number" id="charTracking" step="1" value="0" onchange="applyStyle()"></div>
            </div>

            <div class="row2">
                <div><label>ベースライン</label><input type="number" id="charBaseline" step="1" value="0" onchange="applyStyle()"></div>
                <div><label>傾き°</label><input type="number" id="charSlant" step="0.1" value="0" onchange="applyStyle()"></div>
            </div>

            <div class="row2">
                <div><label>不透明度%</label><input type="number" id="charOpacity" min="0" max="100" value="100" onchange="applyStyle()"></div>
            </div>

            <label><input type="checkbox" id="charSmallCaps" onchange="applyStyle()"> スモールキャップス</label>
            <div class="row2">
                <div><label>サイズ%</label><input type="number" id="charSmallCapsSize" min="10" max="100" value="70" onchange="applyStyle()"></div>
            </div>

            <h4>塗り</h4>
            <label>種類</label>
            <select id="fillType" onchange="applyStyle()">
                <option value="solid">ベタ塗り</option>
                <option value="linear">線形グラデーション</option>
                <option value="radial">円形グラデーション</option>
                <option value="none">透明（塗りなし）</option>
            </select>
            <div id="gradientStops">
                <div class="gradient-stop" data-pos="0">
                    <div class="row2">
                        <div><label>色1</label><input type="color" class="grad-color" value="#ffffff" onchange="applyStyle()"></div>
                        <div><label>比率</label><input type="number" class="grad-ratio" value="50" min="1" max="100" onchange="applyStyle()"></div>
                    </div>
                </div>
                <div class="gradient-stop" data-pos="100">
                    <div class="row2">
                        <div><label>色2</label><input type="color" class="grad-color" value="#888888" onchange="applyStyle()"></div>
                        <div><label>比率</label><input type="number" class="grad-ratio" value="50" min="1" max="100" onchange="applyStyle()"></div>
                    </div>
                </div>
            </div>
            <button class="btn btn-small btn-secondary" onclick="addGradientStop()">+ 色追加</button>
            <div class="row2" id="gradientAngleRow">
                <div><label>角度°</label><input type="number" id="gradientAngle" value="0" step="1" onchange="applyStyle()"></div>
                <div><label>ぼかし</label><input type="number" id="gradientBlur" min="0" max="100" value="0" step="1" onchange="applyStyle()"></div>
            </div>

            <h4>光沢</h4>
            <label><input type="checkbox" id="glossEnabled" onchange="applyStyle()"> 有効</label>
            <div class="row2">
                <div><label>太さ</label><input type="number" id="glossWidth" min="1" max="50" value="10" onchange="applyStyle()"></div>
                <div><label>ぼかし</label><input type="number" id="glossBlur" min="0" max="30" value="5" onchange="applyStyle()"></div>
            </div>
            <div class="row2">
                <div><label>色</label><input type="color" id="glossColor" value="#ffffff" onchange="applyStyle()"></div>
                <div><label>不透明度%</label><input type="number" id="glossOpacity" min="0" max="100" value="50" onchange="applyStyle()"></div>
            </div>

            <label>横揃え</label>
            <div class="align-buttons">
                <button class="align-btn active" data-align="left" onclick="setTextAlign('left')">左</button>
                <button class="align-btn" data-align="center" onclick="setTextAlign('center')">中央</button>
                <button class="align-btn" data-align="right" onclick="setTextAlign('right')">右</button>
            </div>

            <label>縦揃え</label>
            <div class="align-buttons">
                <button class="align-btn" data-valign="top" onclick="setVerticalAlign('top')">上</button>
                <button class="align-btn active" data-valign="middle" onclick="setVerticalAlign('middle')">中央</button>
                <button class="align-btn" data-valign="bottom" onclick="setVerticalAlign('bottom')">下</button>
            </div>
        </div>

        <h3 class="collapsible" onclick="toggleCollapse(this)">縁取り</h3>
        <div class="collapse-content">
            <div id="strokeList"></div>
            <button class="btn btn-small btn-secondary" onclick="addStroke()">+ ストローク追加</button>
        </div>

        <h3 class="collapsible" onclick="toggleCollapse(this)">影</h3>
        <div class="collapse-content">
            <label><input type="checkbox" id="shadowEnabled" onchange="applyStyle()"> 有効</label>
            <div class="row2">
                <div><label>色</label><input type="color" id="shadowColor" value="#000000" onchange="applyStyle()"></div>
                <div><label>不透明度%</label><input type="number" id="shadowOpacity" min="0" max="100" value="50" onchange="applyStyle()"></div>
            </div>
            <div class="row2">
                <div><label>角度°</label><input type="number" id="shadowAngle" value="45" step="1" onchange="applyStyle()"></div>
                <div><label>距離</label><input type="number" id="shadowDistance" value="5" step="1" onchange="applyStyle()"></div>
            </div>
            <div class="row2">
                <div><label>サイズ</label><input type="number" id="shadowSize" value="0" step="1" onchange="applyStyle()"></div>
                <div><label>ぼかし</label><input type="number" id="shadowBlur" value="5" step="1" onchange="applyStyle()"></div>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">名前タグ</h3>
        <div class="collapse-content hidden">
            <label><input type="checkbox" id="nameTagEnabled" onchange="updateNameTag()"> 有効</label>
            <label>名前</label>
            <input type="text" id="nameTagText" placeholder="話者名" onchange="updateNameTag()">
            <label>フォント</label>
            <select id="nameTagFont" onchange="handleNameTagFontChange()" style="width: 100%;">
                <optgroup label="日本語フォント">
                    <option value="Yu Gothic UI">Yu Gothic UI</option>
                    <option value="Meiryo">メイリオ</option>
                    <option value="MS Gothic">MS ゴシック</option>
                    <option value="Hiragino Sans">ヒラギノ角ゴ</option>
                    <option value="Noto Sans JP">Noto Sans JP</option>
                </optgroup>
                <optgroup label="欧文フォント">
                    <option value="Arial">Arial</option>
                    <option value="Impact">Impact</option>
                    <option value="Helvetica">Helvetica</option>
                </optgroup>
                <optgroup id="nameTagSystemFontsGroup" label="システムフォント" style="display:none;">
                </optgroup>
                <optgroup label="カスタム">
                    <option value="__custom__">カスタムフォント...</option>
                </optgroup>
            </select>
            <input type="text" id="nameTagCustomFontInput" placeholder="フォント名を入力" style="display:none; margin-top:5px;" onchange="applyNameTagCustomFont()">
            <div class="row2">
                <div><label>位置</label><select id="nameTagPosition" onchange="updateNameTag()">
                    <option value="top-left">左上</option>
                    <option value="top-center">中央上</option>
                    <option value="top-right">右上</option>
                    <option value="bottom-left">左下</option>
                    <option value="bottom-center">中央下</option>
                    <option value="bottom-right">右下</option>
                </select></div>
                <div><label>間隔</label><input type="number" id="nameTagGap" value="10" step="1" onchange="updateNameTag()"></div>
            </div>
            <div class="row2">
                <div><label>文字色</label><input type="color" id="nameTagColor" value="#ffffff" onchange="updateNameTag()"></div>
                <div><label>サイズ</label><input type="number" id="nameTagSize" value="36" min="1" onchange="updateNameTag()"></div>
            </div>
            <h4>背景</h4>
            <label><input type="checkbox" id="nameTagBgEnabled" checked onchange="updateNameTag()"> 背景表示</label>
            <div class="row2">
                <div><label>形状</label><select id="nameTagBgShape" onchange="updateNameTag()">
                    <option value="rect">四角形</option>
                    <option value="rounded">角丸</option>
                    <option value="pill">ピル型</option>
                </select></div>
                <div><label>角丸</label><input type="number" id="nameTagBgRadius" value="5" min="0" onchange="updateNameTag()"></div>
            </div>
            <div class="row2">
                <div><label>背景色</label><input type="color" id="nameTagBgColor" value="#0078d4" onchange="updateNameTag()"></div>
                <div><label>不透明度%</label><input type="number" id="nameTagBgOpacity" min="0" max="100" value="100" onchange="updateNameTag()"></div>
            </div>
            <div class="row2">
                <div><label>余白X</label><input type="number" id="nameTagPadX" value="10" min="0" onchange="updateNameTag()"></div>
                <div><label>余白Y</label><input type="number" id="nameTagPadY" value="5" min="0" onchange="updateNameTag()"></div>
            </div>
            <h4>縁取り</h4>
            <label><input type="checkbox" id="nameTagStrokeEnabled" onchange="updateNameTag()"> 縁取り表示</label>
            <div class="row2">
                <div><label>色</label><input type="color" id="nameTagStrokeColor" value="#ffffff" onchange="updateNameTag()"></div>
                <div><label>太さ</label><input type="number" id="nameTagStrokeWidth" value="2" min="0" onchange="updateNameTag()"></div>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">吹き出し</h3>
        <div class="collapse-content hidden">
            <label><input type="checkbox" id="balloonEnabled" onchange="updateBalloon()"> 有効</label>
            <div class="row2">
                <div><label>形状</label><select id="balloonShape" onchange="updateBalloon()">
                    <option value="rounded">角丸四角</option>
                    <option value="ellipse">楕円</option>
                    <option value="cloud">雲形</option>
                </select></div>
                <div><label>角丸</label><input type="number" id="balloonRadius" value="20" min="0" onchange="updateBalloon()"></div>
            </div>
            <div class="row2">
                <div><label>余白X</label><input type="number" id="balloonPadX" value="30" min="0" onchange="updateBalloon()"></div>
                <div><label>余白Y</label><input type="number" id="balloonPadY" value="20" min="0" onchange="updateBalloon()"></div>
            </div>
            <h4>塗り</h4>
            <div class="row2">
                <div><label>色</label><input type="color" id="balloonFill" value="#ffffff" onchange="updateBalloon()"></div>
                <div><label>不透明度%</label><input type="number" id="balloonFillOpacity" min="0" max="100" value="100" onchange="updateBalloon()"></div>
            </div>
            <h4>縁取り</h4>
            <label><input type="checkbox" id="balloonStrokeEnabled" checked onchange="updateBalloon()"> 縁取り表示</label>
            <div class="row2">
                <div><label>色</label><input type="color" id="balloonStrokeColor" value="#000000" onchange="updateBalloon()"></div>
                <div><label>太さ</label><input type="number" id="balloonStrokeWidth" value="3" min="0" onchange="updateBalloon()"></div>
            </div>
            <h4>しっぽ</h4>
            <label><input type="checkbox" id="balloonTailEnabled" checked onchange="updateBalloon()"> しっぽ表示</label>
            <div class="row2">
                <div><label>方向</label><select id="balloonTailDir" onchange="updateBalloon()">
                    <option value="bottom">下</option>
                    <option value="top">上</option>
                    <option value="left">左</option>
                    <option value="right">右</option>
                    <option value="bottom-left">左下</option>
                    <option value="bottom-right">右下</option>
                </select></div>
                <div><label>位置%</label><input type="number" id="balloonTailPos" value="50" min="0" max="100" onchange="updateBalloon()"></div>
            </div>
            <div class="row2">
                <div><label>幅</label><input type="number" id="balloonTailWidth" value="20" min="1" onchange="updateBalloon()"></div>
                <div><label>長さ</label><input type="number" id="balloonTailLength" value="30" min="1" onchange="updateBalloon()"></div>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">図形設定</h3>
        <div class="collapse-content hidden" id="shapeSettings">
            <h4>塗り</h4>
            <label>種類</label>
            <select id="shapeFillType" onchange="updateShapeStyle()">
                <option value="solid">ベタ塗り</option>
                <option value="linear">線形グラデーション</option>
                <option value="radial">円形グラデーション</option>
                <option value="none">透明（塗りなし）</option>
            </select>
            <div class="row2">
                <div><label>色</label><input type="color" id="shapeFill" value="#ffffff" onchange="updateShapeStyle()"></div>
                <div><label>不透明度%</label><input type="number" id="shapeFillOpacity" min="0" max="100" value="100" onchange="updateShapeStyle()"></div>
            </div>
            <div id="shapeGradientSettings">
                <div class="row2">
                    <div><label>色2</label><input type="color" id="shapeFill2" value="#888888" onchange="updateShapeStyle()"></div>
                    <div><label>角度°</label><input type="number" id="shapeGradientAngle" value="0" step="1" onchange="updateShapeStyle()"></div>
                </div>
            </div>
            <h4>縁取り</h4>
            <div class="row2">
                <div><label>色</label><input type="color" id="shapeStroke" value="#000000" onchange="updateShapeStyle()"></div>
                <div><label>太さ</label><input type="number" id="shapeStrokeWidth" value="2" min="0" onchange="updateShapeStyle()"></div>
            </div>
            <div class="row2">
                <div><label>不透明度%</label><input type="number" id="shapeStrokeOpacity" min="0" max="100" value="100" onchange="updateShapeStyle()"></div>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">パス上文字設定</h3>
        <div class="collapse-content hidden" id="pathTextSettings">
            <label><input type="checkbox" id="pathTextVertical" onchange="updatePathTextStyle()"> 縦書き</label>
            <label>パスオフセット</label>
            <input type="number" id="pathTextOffset" value="0" step="10" onchange="updatePathTextStyle()">
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">ペンパス設定</h3>
        <div class="collapse-content hidden" id="penPathSettings">
            <h4>塗り</h4>
            <label>種類</label>
            <select id="penPathFillType" onchange="updatePenPathStyle()">
                <option value="none">透明（塗りなし）</option>
                <option value="solid">ベタ塗り</option>
            </select>
            <div class="row2">
                <div><label>色</label><input type="color" id="penPathFill" value="#ffffff" onchange="updatePenPathStyle()"></div>
                <div><label>不透明度%</label><input type="number" id="penPathFillOpacity" min="0" max="100" value="100" onchange="updatePenPathStyle()"></div>
            </div>
            <h4>ストローク</h4>
            <div class="row2">
                <div><label>色</label><input type="color" id="penPathStroke" value="#ffffff" onchange="updatePenPathStyle()"></div>
                <div><label>太さ</label><input type="number" id="penPathStrokeWidth" value="3" min="1" onchange="updatePenPathStyle()"></div>
            </div>
            <div class="row2">
                <div><label>不透明度%</label><input type="number" id="penPathStrokeOpacity" min="0" max="100" value="100" onchange="updatePenPathStyle()"></div>
            </div>
            <div style="margin-top:8px;">
                <label><input type="checkbox" id="penPathClosed" onchange="updatePenPathStyle()"> パスを閉じる</label>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">画像設定</h3>
        <div class="collapse-content hidden" id="imageSettings">
            <div class="row2">
                <div><label>幅</label><input type="number" id="imageWidth" min="1" onchange="updateImageSize()"></div>
                <div><label>高さ</label><input type="number" id="imageHeight" min="1" onchange="updateImageSize()"></div>
            </div>
            <div style="margin-top:8px;">
                <label><input type="checkbox" id="imageLockAspect" checked> 縦横比を維持</label>
            </div>
            <h4>反転</h4>
            <div style="display:flex;gap:5px;">
                <button class="btn btn-small btn-secondary" onclick="flipImage('h')">左右反転</button>
                <button class="btn btn-small btn-secondary" onclick="flipImage('v')">上下反転</button>
            </div>
            <h4>トリミング</h4>
            <div class="row2">
                <div><label>左</label><input type="number" id="imageCropLeft" min="0" value="0" onchange="updateImageCrop()"></div>
                <div><label>上</label><input type="number" id="imageCropTop" min="0" value="0" onchange="updateImageCrop()"></div>
            </div>
            <div class="row2">
                <div><label>右</label><input type="number" id="imageCropRight" min="0" value="0" onchange="updateImageCrop()"></div>
                <div><label>下</label><input type="number" id="imageCropBottom" min="0" value="0" onchange="updateImageCrop()"></div>
            </div>
            <h4>色透過</h4>
            <div class="row2">
                <div><label>色</label><input type="color" id="imageTransparentColor" value="#00ff00" onchange="updateImageTransparency()"></div>
                <div><label>許容値</label><input type="number" id="imageTransparentTolerance" min="0" max="255" value="30" onchange="updateImageTransparency()"></div>
            </div>
            <div style="margin-top:5px;">
                <label><input type="checkbox" id="imageTransparentEnabled" onchange="updateImageTransparency()"> 透過有効</label>
                <button class="btn btn-small btn-secondary" onclick="pickTransparentColor()" style="margin-left:5px;">スポイト</button>
            </div>
            <h4>ストローク</h4>
            <div class="row2">
                <div><label>色</label><input type="color" id="imageStrokeColor" value="#000000" onchange="updateImageStroke()"></div>
                <div><label>太さ</label><input type="number" id="imageStrokeWidth" value="0" min="0" onchange="updateImageStroke()"></div>
            </div>
        </div>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">アニメーション</h3>
        <div class="collapse-content hidden" id="animationSettings">
            <div><label>種類</label>
                <select id="animType" onchange="updateAnimation()">
                    <option value="none">なし</option>
                    <option value="fadeIn">フェードイン</option>
                    <option value="fadeOut">フェードアウト</option>
                    <option value="slideLeft">左からスライド</option>
                    <option value="slideRight">右からスライド</option>
                    <option value="slideUp">上からスライド</option>
                    <option value="slideDown">下からスライド</option>
                    <option value="typewriter">タイプライター</option>
                    <option value="rotateIn">回転出現</option>
                    <option value="cursorReveal">カーソル追従</option>
                    <option value="zoomIn">ズームイン</option>
                    <option value="splitMerge">分割合体</option>
                    <option value="slot">スロット</option>
                    <option value="rollUp">縦エンドロール</option>
                    <option value="rollLeft">横エンドロール</option>
                </select>
            </div>
            <div class="row2">
                <div><label>時間(秒)</label><input type="number" id="animDuration" value="2" min="0.1" step="0.1" onchange="updateAnimation()"></div>
                <div><label>遅延(秒)</label><input type="number" id="animDelay" value="0" min="0" step="0.1" onchange="updateAnimation()"></div>
            </div>
            <div class="row2">
                <div><label>速度</label><input type="number" id="animSpeed" value="100" min="10" step="10" onchange="updateAnimation()"></div>
            </div>
            <div style="margin-top:8px;">
                <label>イージング</label>
                <select id="animEasing" onchange="updateAnimation()">
                    <option value="linear">リニア</option>
                    <option value="easeIn">イーズイン</option>
                    <option value="easeOut">イーズアウト</option>
                    <option value="easeInOut">イーズインアウト</option>
                </select>
            </div>
            <div style="margin-top:8px;">
                <label><input type="checkbox" id="animLoop" onchange="updateAnimation()"> ループ再生</label>
            </div>
            <h4 style="margin-top:12px;">キーフレーム</h4>
            <div id="keyframeList" style="max-height:200px;overflow-y:auto;border:1px solid #555;padding:5px;margin-bottom:8px;"></div>
            <div style="display:flex;gap:5px;">
                <button class="btn btn-small btn-secondary" onclick="addKeyframe()">追加</button>
                <button class="btn btn-small btn-secondary" onclick="addKeyframeFromCurrent()">現在値で追加</button>
            </div>
        </div>

        <h3>出力</h3>
        <div style="margin-bottom:8px;">
            <label><input type="checkbox" id="exportTransparent"> 背景透過</label>
        </div>
        <div class="row2" style="margin-bottom:8px;">
            <div><label>FPS</label><input type="number" id="exportFps" value="30" min="1" max="60"></div>
            <div><label>時間(秒)</label><input type="number" id="exportDuration" value="3" min="0.1" step="0.1"></div>
        </div>
        <button class="btn btn-primary" onclick="exportPNG()">PNG書き出し</button>
        <button class="btn btn-secondary" onclick="exportSequencePNG()">連番PNG</button>
        <button class="btn btn-secondary" onclick="exportGIF()">GIF書き出し</button>
        <button class="btn btn-secondary" onclick="saveProject()">プロジェクト保存</button>
        <button class="btn btn-secondary" onclick="loadProject()">プロジェクト読込</button>

        <h3 class="collapsible collapsed" onclick="toggleCollapse(this)">スタイルインポート</h3>
        <div class="collapse-content hidden">
            <button class="btn btn-secondary" onclick="importPRSL()">PRSL読込</button>
            <input type="file" id="prslInput" accept=".prsl" style="display:none" onchange="handlePRSLLoad(event)">
            <div id="prslStatus" style="font-size:11px;color:#888;margin-top:4px;"></div>
            <div id="prslStyleList" style="max-height:150px;overflow-y:auto;margin-top:8px;"></div>
        </div>
    </div>

    <div class="main">
        <div class="toolbar">
            <select id="resolution" onchange="changeResolution()">
                <option value="1920x1080">1920×1080</option>
                <option value="3840x2160">3840×2160</option>
            </select>
            <span id="toolHint" style="font-size:10px;color:#666;">選択ツール (V)</span>
        </div>
        <div class="canvas-container">
            <canvas id="canvas" width="1920" height="1080"></canvas>
        </div>
        <div class="bottom-toolbar">
            <!-- Undo/Redo -->
            <div class="tool-group">
                <button class="tool-icon" id="undoBtn" onclick="undo()" title="元に戻す (Ctrl+Z)" disabled>
                    <svg viewBox="0 0 24 24"><path d="M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8z"/></svg>
                </button>
                <button class="tool-icon" id="redoBtn" onclick="redo()" title="やり直し (Ctrl+Y)" disabled>
                    <svg viewBox="0 0 24 24"><path d="M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7l-3.6 3.6z"/></svg>
                </button>
            </div>
            <!-- 選択/回転ツール -->
            <div class="tool-group">
                <button class="tool-icon active" id="toolSelect" onclick="setTool('select')" title="選択 (V)">
                    <svg viewBox="0 0 24 24"><path d="M7 2l10 10-4 1 3 5-2 1-3-5-4 4z"/></svg>
                </button>
                <button class="tool-icon" id="toolRotate" onclick="setTool('rotate')" title="回転 (R)">
                    <svg viewBox="0 0 24 24"><path d="M12 6v3l4-4-4-4v3a8 8 0 00-8 8h2a6 6 0 016-6zm8 2a8 8 0 01-8 8v-3l-4 4 4 4v-3a8 8 0 008-8h-2z"/></svg>
                </button>
            </div>
            <!-- テキストツール -->
            <div class="tool-group">
                <button class="tool-icon" id="toolText" onclick="setTool('text')" title="横書きテキスト (T)">
                    <span>T</span>
                </button>
                <button class="tool-icon" id="toolTextV" onclick="setTool('textV')" title="縦書きテキスト">
                    <span style="font-size:9px;">↓T</span>
                </button>
            </div>
            <!-- 図形ツール -->
            <div class="tool-group">
                <button class="tool-icon" id="toolRect" onclick="setTool('rect')" title="長方形">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolRoundRect" onclick="setTool('roundRect')" title="角丸長方形">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="4" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolEllipse" onclick="setTool('ellipse')" title="楕円">
                    <svg viewBox="0 0 24 24"><ellipse cx="12" cy="12" rx="9" ry="9" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolTriangle" onclick="setTool('triangle')" title="三角形">
                    <svg viewBox="0 0 24 24"><path d="M12 4L3 20h18z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolLine" onclick="setTool('line')" title="ライン">
                    <svg viewBox="0 0 24 24"><line x1="4" y1="20" x2="20" y2="4" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolChamferRect" onclick="setTool('chamferRect')" title="斜角長方形">
                    <svg viewBox="0 0 24 24"><path d="M7 3h10l4 4v10l-4 4H7l-4-4V7z" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
                <button class="tool-icon" id="toolArc" onclick="setTool('arc')" title="円弧">
                    <svg viewBox="0 0 24 24"><path d="M4 12a8 8 0 0 1 16 0" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
            </div>
            <!-- ペンツール -->
            <div class="tool-group">
                <button class="tool-icon" id="toolPen" onclick="setTool('pen')" title="ペンツール (P)">
                    <svg viewBox="0 0 24 24"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zM20.71 7.04a.996.996 0 000-1.41l-2.34-2.34a.996.996 0 00-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>
                </button>
                <button class="tool-icon" id="toolPathText" onclick="setTool('pathText')" title="パス上文字">
                    <svg viewBox="0 0 24 24"><path d="M3 17c3-2 6-6 9-6s6 4 9 6" fill="none" stroke="currentColor" stroke-width="2"/><text x="12" y="10" font-size="8" fill="currentColor" text-anchor="middle">T</text></svg>
                </button>
            </div>
            <!-- 画像 -->
            <div class="tool-group">
                <button class="tool-icon" onclick="insertImage()" title="画像挿入">
                    <svg viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" fill="none" stroke="currentColor" stroke-width="2"/><circle cx="8.5" cy="8.5" r="1.5" fill="currentColor"/><path d="M21 15l-5-5L5 21" fill="none" stroke="currentColor" stroke-width="2"/></svg>
                </button>
            </div>
            <!-- 整列 -->
            <div class="tool-group">
                <button class="tool-icon" onclick="alignToCenter('h')" title="たて中央">
                    <svg viewBox="0 0 24 24"><path d="M8 19h3v4h2v-4h3l-4-4-4 4zm8-14h-3V1h-2v4H8l4 4 4-4zM4 11v2h16v-2H4z"/></svg>
                </button>
                <button class="tool-icon" onclick="alignToCenter('v')" title="よこ中央">
                    <svg viewBox="0 0 24 24"><path d="M19 16v-3h4v-2h-4V8l-4 4 4 4zM5 8v3H1v2h4v3l4-4-4-4zm6-4h2v16h-2V4z"/></svg>
                </button>
            </div>
            <!-- アニメーション -->
            <div class="tool-group">
                <button class="tool-icon" id="playBtn" onclick="toggleAnimation()" title="再生/停止 (Space)">
                    <svg viewBox="0 0 24 24" id="playIcon"><path d="M8 5v14l11-7z" fill="currentColor"/></svg>
                </button>
                <button class="tool-icon" onclick="resetAnimation()" title="リセット">
                    <svg viewBox="0 0 24 24"><path d="M12 5V1L7 6l5 5V7c3.31 0 6 2.69 6 6s-2.69 6-6 6-6-2.69-6-6H4c0 4.42 3.58 8 8 8s8-3.58 8-8-3.58-8-8-8z" fill="currentColor"/></svg>
                </button>
            </div>
            <!-- タイムライン -->
            <div class="tool-group" style="flex:1;max-width:200px;">
                <input type="range" id="timeline" min="0" max="100" value="0" style="width:100%;" oninput="seekAnimation(this.value)">
            </div>
        </div>
        <div class="status">
            <span id="statusText">準備完了</span>
            <span id="resolution-display">1920×1080</span>
        </div>
    </div>

    <!-- Right sidebar for canvas thumbnails -->
    <div class="right-sidebar">
        <h3>キャンバス</h3>
        <div class="canvas-actions">
            <button class="btn btn-primary" onclick="newCanvas()">新規</button>
            <button class="btn btn-secondary" onclick="duplicateCanvas()">複製</button>
        </div>
        <div class="canvas-actions">
            <button class="btn btn-secondary" onclick="importCanvasFromProject()">インポート</button>
        </div>
        <div class="canvas-list" id="canvasList"></div>
    </div>

    <input type="file" id="fileInput" accept=".json" style="display:none" onchange="handleFileLoad(event)">
    <input type="file" id="importFileInput" accept=".json" style="display:none" onchange="handleImportProject(event)">
    <input type="file" id="imageInput" accept="image/*" style="display:none" onchange="handleImageLoad(event)">
    <input type="text" id="imeInput" autocomplete="off">

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imeInput = document.getElementById('imeInput');

        // 複数キャンバス管理
        let canvases = [];
        let activeCanvasId = null;

        // 現在のキャンバスのオブジェクト（後方互換性のため維持）
        let textObjects = [];
        let selectedObjId = null;
        let selectedCharStart = -1;
        let selectedCharEnd = -1;
        let isDragging = false;
        let isSelecting = false;
        let isResizing = false;
        let isRotating = false;
        let isDrawingShape = false;
        let resizeHandle = null;
        let dragOffset = { x: 0, y: 0 };
        let resizeStart = {};
        let rotateStart = {};
        let shapeStart = {};
        let tempShape = null;
        let scale = 1;
        let editingObjId = null;
        let cursorPos = 0;
        let cursorVisible = true;
        let cursorInterval = null;
        let currentTool = 'select';
        let isComposing = false;
        let pathPoints = [];  // パス描画中のポイント
        let isDrawingPath = false;
        let penDragging = false;  // ペンツールでドラッグ中
        let penDragStart = null;  // ドラッグ開始位置
        let editingPenPath = null;  // 制御点編集中のパスオブジェクトID
        let editingControlPoint = null;  // 編集中の制御点 {pointIndex, type: 'cp1'|'cp2'|'anchor'}
        let textEditSaveTimer = null;  // テキスト編集Undoのデバウンスタイマー
        let lastSavedState = null;  // 最後に保存した状態（重複保存を防ぐ）
        let clipboard = null;  // コピーしたオブジェクト
        let exportingTransparent = false;  // 透過エクスポート中
        let selectedObjIds = [];  // 複数選択中のオブジェクトID
        let bgImage = null;   // 背景画像
        let canvasBgColor = '#000000';
        let canvasBgOpacity = 0;

        // アニメーション関連
        let isPlaying = false;
        let animationTime = 0;
        let animationFrame = null;
        let animationStartTime = 0;
        let totalDuration = 5;  // 総再生時間（秒）

        // ========== Undo/Redo 履歴管理 ==========
        let undoStack = [];
        let redoStack = [];
        const MAX_HISTORY = 50;

        function saveState() {
            const state = JSON.stringify(textObjects);
            // 同じ状態を連続して保存しない
            if (state === lastSavedState) return;
            undoStack.push(state);
            lastSavedState = state;
            if (undoStack.length > MAX_HISTORY) undoStack.shift();
            redoStack = [];  // 新しい操作でredoスタックをクリア
            updateUndoRedoButtons();
        }

        // テキスト編集中のデバウンスsaveState（500ms後に保存）
        function debouncedSaveState() {
            if (textEditSaveTimer) clearTimeout(textEditSaveTimer);
            textEditSaveTimer = setTimeout(() => {
                saveState();
                textEditSaveTimer = null;
            }, 500);
        }

        // 即座にデバウンスをフラッシュ
        function flushDebouncedSave() {
            if (textEditSaveTimer) {
                clearTimeout(textEditSaveTimer);
                saveState();
                textEditSaveTimer = null;
            }
        }

        function undo() {
            if (undoStack.length === 0) return;
            const currentState = JSON.stringify(textObjects);
            redoStack.push(currentState);
            const prevState = undoStack.pop();
            textObjects = JSON.parse(prevState);
            selectedObjId = null;
            selectedObjIds = [];
            exitEditMode();
            updateLayerList();
            updateLayerProps();
            render();
            updateUndoRedoButtons();
        }

        function redo() {
            if (redoStack.length === 0) return;
            const currentState = JSON.stringify(textObjects);
            undoStack.push(currentState);
            const nextState = redoStack.pop();
            textObjects = JSON.parse(nextState);
            selectedObjId = null;
            selectedObjIds = [];
            exitEditMode();
            updateLayerList();
            updateLayerProps();
            render();
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            const undoBtn = document.getElementById('undoBtn');
            const redoBtn = document.getElementById('redoBtn');
            if (undoBtn) undoBtn.disabled = undoStack.length === 0;
            if (redoBtn) redoBtn.disabled = redoStack.length === 0;
        }

        function toggleCollapse(el) {
            el.classList.toggle('collapsed');
            el.nextElementSibling.classList.toggle('hidden');
        }

        // ========== フォント管理 ==========
        let loadedSystemFonts = [];
        let currentCustomFont = '';
        let nameTagCustomFont = '';

        // CEP環境検出
        function isInCEP() {
            try {
                return typeof require !== 'undefined' &&
                       typeof CSInterface !== 'undefined';
            } catch(e) {
                return false;
            }
        }

        // システムフォント読み込み（CEP環境用）
        async function loadSystemFonts() {
            if (!isInCEP()) return;

            try {
                const fontList = require('font-list');
                const fonts = await fontList.getFonts();
                loadedSystemFonts = fonts.map(f => f.replace(/"/g, '')).sort();

                // システムフォントグループを表示・更新
                const groups = ['systemFontsGroup', 'nameTagSystemFontsGroup'];
                groups.forEach(groupId => {
                    const group = document.getElementById(groupId);
                    if (group) {
                        group.style.display = '';
                        group.innerHTML = '';
                        loadedSystemFonts.forEach(font => {
                            const option = document.createElement('option');
                            option.value = font;
                            option.textContent = font;
                            group.appendChild(option);
                        });
                    }
                });

                console.log(`Loaded ${loadedSystemFonts.length} system fonts`);
            } catch(e) {
                console.warn('Failed to load system fonts:', e);
            }
        }

        // フォント選択ハンドラ（メインテキスト用）
        function handleFontChange() {
            const select = document.getElementById('fontFamily');
            const customInput = document.getElementById('customFontInput');

            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.focus();
                if (currentCustomFont) {
                    customInput.value = currentCustomFont;
                }
            } else {
                customInput.style.display = 'none';
                applyStyle();
            }
        }

        // カスタムフォント適用（メインテキスト用）
        function applyCustomFont() {
            const customInput = document.getElementById('customFontInput');
            const fontName = customInput.value.trim();
            if (fontName) {
                currentCustomFont = fontName;
                applyStyle();
            }
        }

        // フォント選択ハンドラ（名前タグ用）
        function handleNameTagFontChange() {
            const select = document.getElementById('nameTagFont');
            const customInput = document.getElementById('nameTagCustomFontInput');

            if (select.value === '__custom__') {
                customInput.style.display = 'block';
                customInput.focus();
                if (nameTagCustomFont) {
                    customInput.value = nameTagCustomFont;
                }
            } else {
                customInput.style.display = 'none';
                updateNameTag();
            }
        }

        // カスタムフォント適用（名前タグ用）
        function applyNameTagCustomFont() {
            const customInput = document.getElementById('nameTagCustomFontInput');
            const fontName = customInput.value.trim();
            if (fontName) {
                nameTagCustomFont = fontName;
                updateNameTag();
            }
        }

        // 現在選択されているフォント名を取得
        function getSelectedFont(selectId, customFontVar) {
            const select = document.getElementById(selectId);
            if (select.value === '__custom__') {
                return customFontVar || 'Yu Gothic UI';
            }
            return select.value;
        }

        // フォント初期化
        function initFonts() {
            // CEP環境ならシステムフォントを読み込む
            if (isInCEP()) {
                loadSystemFonts();
            }
        }

        // ========== キャンバス管理 ==========

        function createCanvasData(name) {
            return {
                id: Date.now() + Math.random(),
                name: name || `キャンバス ${canvases.length + 1}`,
                resolution: document.getElementById('resolution').value,
                bgColor: '#000000',
                bgOpacity: 0,
                bgImageData: null,
                objects: []
            };
        }

        function newCanvas() {
            // 現在のキャンバスを保存
            saveCurrentCanvas();

            // 新規キャンバス作成
            const newCanvasData = createCanvasData();
            canvases.push(newCanvasData);
            switchCanvas(newCanvasData.id);
            updateCanvasList();
        }

        function duplicateCanvas() {
            if (!activeCanvasId) return;

            // 現在のキャンバスを保存
            saveCurrentCanvas();

            // 現在のキャンバスを複製
            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            const duplicate = JSON.parse(JSON.stringify(current));
            duplicate.id = Date.now() + Math.random();
            duplicate.name = current.name + ' (コピー)';
            canvases.push(duplicate);
            switchCanvas(duplicate.id);
            updateCanvasList();
        }

        function deleteCanvas(id) {
            if (canvases.length <= 1) {
                alert('最後のキャンバスは削除できません');
                return;
            }

            const index = canvases.findIndex(c => c.id === id);
            if (index === -1) return;

            if (!confirm(`"${canvases[index].name}" を削除しますか？`)) return;

            canvases.splice(index, 1);

            // 削除したのがアクティブなら別のキャンバスに切替
            if (id === activeCanvasId) {
                const newIndex = Math.min(index, canvases.length - 1);
                switchCanvas(canvases[newIndex].id);
            }
            updateCanvasList();
        }

        function switchCanvas(id) {
            if (id === activeCanvasId) return;

            // 現在のキャンバスを保存
            saveCurrentCanvas();

            // 新しいキャンバスに切替
            activeCanvasId = id;
            loadCurrentCanvas();
            updateCanvasList();
        }

        function saveCurrentCanvas() {
            if (!activeCanvasId) return;

            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            current.objects = JSON.parse(JSON.stringify(textObjects));
            current.resolution = document.getElementById('resolution').value;
            current.bgColor = canvasBgColor;
            current.bgOpacity = canvasBgOpacity;

            // サムネイルを保存（セーフマージン非表示で）
            const wasEnabled = document.getElementById('safeMarginEnabled').checked;
            document.getElementById('safeMarginEnabled').checked = false;
            const prevSelected = selectedObjId;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;  // 選択枠を非表示
            selectedObjIds = [];
            render();
            current.thumbnail = canvas.toDataURL('image/png');
            selectedObjId = prevSelected;
            selectedObjIds = prevSelectedIds;
            document.getElementById('safeMarginEnabled').checked = wasEnabled;
            render();

            // 背景画像をBase64で保存
            if (bgImage) {
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = bgImage.width;
                tempCanvas.height = bgImage.height;
                tempCanvas.getContext('2d').drawImage(bgImage, 0, 0);
                current.bgImageData = tempCanvas.toDataURL();
            } else {
                current.bgImageData = null;
            }
        }

        function loadCurrentCanvas() {
            const current = canvases.find(c => c.id === activeCanvasId);
            if (!current) return;

            textObjects = JSON.parse(JSON.stringify(current.objects));
            selectedObjId = null;
            selectedObjIds = [];
            editingObjId = null;

            // 解像度を設定
            if (current.resolution) {
                document.getElementById('resolution').value = current.resolution;
                changeResolution();
            }

            // 背景色を設定
            canvasBgColor = current.bgColor || '#000000';
            canvasBgOpacity = current.bgOpacity || 0;
            document.getElementById('canvasBgColor').value = canvasBgColor;
            document.getElementById('canvasBgOpacity').value = canvasBgOpacity;

            // 背景画像を読み込み
            if (current.bgImageData) {
                const img = new Image();
                img.onload = function() {
                    bgImage = img;
                    render();
                };
                img.src = current.bgImageData;
            } else {
                bgImage = null;
            }

            updateLayerList();
            render();
        }

        function renameCanvas(id) {
            const canvasData = canvases.find(c => c.id === id);
            if (!canvasData) return;

            const newName = prompt('キャンバス名を入力:', canvasData.name);
            if (newName && newName.trim()) {
                canvasData.name = newName.trim();
                updateCanvasList();
            }
        }

        function updateCanvasList() {
            const list = document.getElementById('canvasList');
            list.innerHTML = '';

            canvases.forEach(canvasData => {
                const div = document.createElement('div');
                div.className = 'canvas-thumb' + (canvasData.id === activeCanvasId ? ' active' : '');
                div.onclick = () => switchCanvas(canvasData.id);

                // サムネイル生成
                const thumbUrl = generateCanvasThumbnail(canvasData);

                div.innerHTML = `
                    <img src="${thumbUrl}" alt="${canvasData.name}">
                    <div class="canvas-thumb-name">${canvasData.name}</div>
                    <div class="canvas-thumb-actions">
                        <button class="canvas-thumb-btn" onclick="event.stopPropagation(); renameCanvas(${canvasData.id})" title="名前変更">✎</button>
                        <button class="canvas-thumb-btn" onclick="event.stopPropagation(); deleteCanvas(${canvasData.id})" title="削除">×</button>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function generateCanvasThumbnail(canvasData) {
            // 現在のキャンバスの場合は実際のキャンバスからサムネイル生成
            if (canvasData.id === activeCanvasId) {
                // セーフマージン非表示で描画
                const wasEnabled = document.getElementById('safeMarginEnabled').checked;
                document.getElementById('safeMarginEnabled').checked = false;
                const prevSelected = selectedObjId;
                const prevSelectedIds = [...selectedObjIds];
                selectedObjId = null;  // 選択枠を非表示
                selectedObjIds = [];
                render();
                const url = canvas.toDataURL('image/png');
                selectedObjId = prevSelected;
                selectedObjIds = prevSelectedIds;
                document.getElementById('safeMarginEnabled').checked = wasEnabled;
                render();
                return url;
            }

            // 保存されたサムネイルがあればそれを使用
            if (canvasData.thumbnail) {
                return canvasData.thumbnail;
            }

            // 保存されたサムネイルがない場合は簡易プレビュー
            const [w, h] = (canvasData.resolution || '1920x1080').split('x').map(Number);
            const thumbCanvas = document.createElement('canvas');
            thumbCanvas.width = w;
            thumbCanvas.height = h;
            const thumbCtx = thumbCanvas.getContext('2d');

            // 背景
            thumbCtx.fillStyle = '#1a1a1a';
            thumbCtx.fillRect(0, 0, w, h);

            // 簡易テキストプレビュー
            if (canvasData.objects && canvasData.objects.length > 0) {
                thumbCtx.fillStyle = '#666';
                thumbCtx.font = '48px sans-serif';
                thumbCtx.textAlign = 'center';
                thumbCtx.fillText(`${canvasData.objects.length} objects`, w/2, h/2);
            }

            return thumbCanvas.toDataURL('image/png');
        }

        function importCanvasFromProject() {
            document.getElementById('importFileInput').click();
        }

        function handleImportProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const project = JSON.parse(e.target.result);

                    // v3.0形式（複数キャンバス）
                    if (project.canvases && project.canvases.length > 0) {
                        const names = project.canvases.map(c => c.name).join('\n');
                        if (confirm(`以下のキャンバスをインポートしますか？\n\n${names}`)) {
                            project.canvases.forEach(imported => {
                                imported.id = Date.now() + Math.random();
                                imported.name = imported.name + ' (インポート)';
                                canvases.push(imported);
                            });
                            updateCanvasList();
                        }
                    }
                    // v2.x形式（単一キャンバス）
                    else if (project.objects) {
                        const name = prompt('インポートするキャンバスの名前:', 'インポート');
                        if (name) {
                            const imported = createCanvasData(name);
                            imported.objects = project.objects;
                            imported.resolution = project.resolution || '1920x1080';
                            canvases.push(imported);
                            updateCanvasList();
                        }
                    }
                } catch (err) {
                    alert('ファイルの読み込みに失敗しました: ' + err.message);
                }
            };
            reader.readAsText(file);
            event.target.value = '';
        }

        // 初期キャンバス作成
        function initCanvases() {
            if (canvases.length === 0) {
                const initial = createCanvasData('キャンバス 1');
                canvases.push(initial);
                activeCanvasId = initial.id;
            }
            updateCanvasList();
        }

        // ========== 背景・セーフマージン管理 ==========

        function updateCanvasBackground() {
            canvasBgColor = document.getElementById('canvasBgColor').value;
            canvasBgOpacity = parseInt(document.getElementById('canvasBgOpacity').value) || 0;
            render();
        }

        function loadBackgroundImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    bgImage = img;
                    render();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function clearBackgroundImage() {
            bgImage = null;
            document.getElementById('bgImageInput').value = '';
            render();
        }

        function drawBackground(ctx) {
            // 透過エクスポート中は背景をスキップ
            if (exportingTransparent) return;

            // 背景色（不透明度が0より大きい場合のみ描画）
            if (canvasBgOpacity > 0) {
                ctx.save();
                ctx.globalAlpha = canvasBgOpacity / 100;
                ctx.fillStyle = canvasBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.restore();
            }

            // 背景画像
            if (bgImage) {
                const fit = document.getElementById('bgImageFit').value;
                ctx.save();

                let dx = 0, dy = 0, dw = canvas.width, dh = canvas.height;

                if (fit === 'contain') {
                    const scale = Math.min(canvas.width / bgImage.width, canvas.height / bgImage.height);
                    dw = bgImage.width * scale;
                    dh = bgImage.height * scale;
                    dx = (canvas.width - dw) / 2;
                    dy = (canvas.height - dh) / 2;
                } else if (fit === 'cover') {
                    const scale = Math.max(canvas.width / bgImage.width, canvas.height / bgImage.height);
                    dw = bgImage.width * scale;
                    dh = bgImage.height * scale;
                    dx = (canvas.width - dw) / 2;
                    dy = (canvas.height - dh) / 2;
                }
                // stretch uses default values

                ctx.drawImage(bgImage, dx, dy, dw, dh);
                ctx.restore();
            }
        }

        function drawSafeMargins(ctx) {
            if (!document.getElementById('safeMarginEnabled').checked) return;

            const actionMargin = parseInt(document.getElementById('actionSafeMargin').value) || 5;
            const titleMargin = parseInt(document.getElementById('titleSafeMargin').value) || 10;
            const color = document.getElementById('safeMarginColor').value;
            const opacity = (parseInt(document.getElementById('safeMarginOpacity').value) || 50) / 100;

            // Parse color to RGB
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);

            ctx.save();
            ctx.strokeStyle = `rgba(${r},${g},${b},${opacity})`;
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);

            const w = canvas.width;
            const h = canvas.height;

            // アクションセーフ（外側のマージン）
            const ax = w * actionMargin / 100;
            const ay = h * actionMargin / 100;
            ctx.strokeRect(ax, ay, w - ax * 2, h - ay * 2);

            // タイトルセーフ（内側のマージン）
            const tx = w * titleMargin / 100;
            const ty = h * titleMargin / 100;
            ctx.strokeRect(tx, ty, w - tx * 2, h - ty * 2);

            // 中心線
            ctx.setLineDash([2, 4]);
            ctx.beginPath();
            ctx.moveTo(w / 2, 0);
            ctx.lineTo(w / 2, h);
            ctx.moveTo(0, h / 2);
            ctx.lineTo(w, h / 2);
            ctx.stroke();

            ctx.setLineDash([]);
            ctx.restore();
        }

        // ========== グラデーション管理 ==========

        function getGradientStopsFromUI() {
            const rawStops = [];
            document.querySelectorAll('.gradient-stop').forEach(el => {
                rawStops.push({
                    color: el.querySelector('.grad-color').value,
                    ratio: parseInt(el.querySelector('.grad-ratio').value) || 1
                });
            });

            // Calculate positions from ratios
            const total = rawStops.reduce((sum, s) => sum + s.ratio, 0);
            const stops = [];
            let cumulative = 0;

            rawStops.forEach((s, i) => {
                // Start position of this color's range
                const startPos = cumulative / total * 100;
                cumulative += s.ratio;
                // End position of this color's range
                const endPos = cumulative / total * 100;

                stops.push({
                    color: s.color,
                    ratio: s.ratio,
                    pos: startPos,
                    endPos: endPos
                });
            });

            return stops;
        }

        function addGradientStop() {
            const container = document.getElementById('gradientStops');
            const stops = container.children.length;
            const div = document.createElement('div');
            div.className = 'gradient-stop';
            div.innerHTML = `
                <div class="row2">
                    <div><label>色${stops + 1}</label><input type="color" class="grad-color" value="#cccccc" onchange="applyStyle()"></div>
                    <div><label>比率</label><input type="number" class="grad-ratio" value="30" min="1" max="100" onchange="applyStyle()"></div>
                </div>
                <button class="remove-stop" onclick="this.parentElement.remove();applyStyle()">×</button>
            `;
            container.appendChild(div);
            applyStyle();
        }

        function getDefaultStyle() {
            const gradStops = getGradientStopsFromUI();
            return {
                fontSize: parseInt(document.getElementById('fontSize').value),
                fontFamily: getSelectedFont('fontFamily', currentCustomFont),
                fillType: document.getElementById('fillType').value,
                color: gradStops[0]?.color || '#ffffff',
                color2: gradStops[gradStops.length - 1]?.color || '#888888',
                gradientStops: gradStops,
                gradientAngle: parseInt(document.getElementById('gradientAngle').value),
                gradientBlur: parseInt(document.getElementById('gradientBlur').value),
                opacity: parseInt(document.getElementById('charOpacity').value),
                strokes: getStrokesFromUI(),
                shadowEnabled: document.getElementById('shadowEnabled').checked,
                shadowColor: document.getElementById('shadowColor').value,
                shadowOpacity: parseInt(document.getElementById('shadowOpacity').value),
                shadowAngle: parseInt(document.getElementById('shadowAngle').value),
                shadowDistance: parseInt(document.getElementById('shadowDistance').value),
                shadowSize: parseInt(document.getElementById('shadowSize').value),
                shadowBlur: parseInt(document.getElementById('shadowBlur').value),
                glossEnabled: document.getElementById('glossEnabled').checked,
                glossWidth: parseInt(document.getElementById('glossWidth').value),
                glossBlur: parseInt(document.getElementById('glossBlur').value),
                glossColor: document.getElementById('glossColor').value,
                glossOpacity: parseInt(document.getElementById('glossOpacity').value),
                scaleX: parseInt(document.getElementById('charScaleX').value),
                kerning: parseInt(document.getElementById('charKerning').value),
                tracking: parseInt(document.getElementById('charTracking').value),
                baselineShift: parseInt(document.getElementById('charBaseline').value),
                slant: parseFloat(document.getElementById('charSlant').value),
                smallCaps: document.getElementById('charSmallCaps').checked,
                smallCapsSize: parseInt(document.getElementById('charSmallCapsSize').value)
            };
        }

        function getStrokesFromUI() {
            const strokes = [];
            document.querySelectorAll('.stroke-item').forEach((item, i) => {
                strokes.push({
                    enabled: item.querySelector('.stroke-enabled').checked,
                    type: item.querySelector('.stroke-type').value,
                    color: item.querySelector('.stroke-color').value,
                    width: parseInt(item.querySelector('.stroke-width').value),
                    opacity: parseInt(item.querySelector('.stroke-opacity').value),
                    angle: parseInt(item.querySelector('.stroke-angle').value) || 45,
                    join: item.querySelector('.stroke-join').value || 'round'
                });
            });
            return strokes.length ? strokes : [{ enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, angle: 45, join: 'round' }];
        }

        function addStroke() {
            const list = document.getElementById('strokeList');
            const idx = list.children.length;
            const div = document.createElement('div');
            div.className = 'stroke-item';
            div.innerHTML = `
                <div class="stroke-header">
                    <label><input type="checkbox" class="stroke-enabled" checked onchange="applyStyle()"> ストローク${idx + 1}</label>
                    <button class="btn btn-small btn-danger" onclick="this.parentElement.parentElement.remove();applyStyle()">×</button>
                </div>
                <div class="row2">
                    <div><label>種類</label><select class="stroke-type" onchange="applyStyle()">
                        <option value="edge">エッジ</option>
                        <option value="depth">奥行き</option>
                        <option value="drop">ドロップ</option>
                    </select></div>
                    <div><label>色</label><input type="color" class="stroke-color" value="#000000" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>太さ</label><input type="number" class="stroke-width" value="4" min="0" max="50" onchange="applyStyle()"></div>
                    <div><label>不透明度%</label><input type="number" class="stroke-opacity" value="100" min="0" max="100" onchange="applyStyle()"></div>
                </div>
                <div class="row2">
                    <div><label>角度°</label><input type="number" class="stroke-angle" value="45" step="1" onchange="applyStyle()"></div>
                    <div><label>角</label><select class="stroke-join" onchange="applyStyle()">
                        <option value="round">丸み</option>
                        <option value="miter">角</option>
                        <option value="bevel">面取り</option>
                    </select></div>
                </div>
            `;
            list.appendChild(div);
        }

        // 初期ストローク
        addStroke();

        // フォント初期化（CEP環境でシステムフォント読み込み）
        initFonts();

        function setTool(tool) {
            currentTool = tool;
            // Update all tool icon states
            document.querySelectorAll('.tool-icon').forEach(el => el.classList.remove('active'));
            const toolEl = document.getElementById('tool' + tool.charAt(0).toUpperCase() + tool.slice(1));
            if (toolEl) toolEl.classList.add('active');

            // Set cursor and hint
            const toolNames = {
                select: '選択ツール (V)',
                rotate: '回転ツール (R)',
                text: '横書きテキスト (T)',
                textV: '縦書きテキスト',
                rect: '長方形ツール',
                roundRect: '角丸長方形ツール',
                ellipse: '楕円ツール',
                triangle: '三角形ツール',
                line: 'ラインツール',
                chamferRect: '斜角長方形ツール',
                arc: '円弧ツール',
                pen: 'ペンツール',
                pathText: 'パス上文字ツール'
            };
            document.getElementById('toolHint').textContent = toolNames[tool] || tool;

            // Set cursor
            if (tool === 'text' || tool === 'textV') {
                canvas.style.cursor = 'text';
            } else if (tool === 'rotate') {
                canvas.style.cursor = 'grab';
            } else if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc', 'pen', 'pathText'].includes(tool)) {
                canvas.style.cursor = 'crosshair';
            } else {
                canvas.style.cursor = 'default';
            }

            if (tool === 'select' && editingObjId) exitEditMode();
        }

        function alignToCenter(axis) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            const bounds = getObjectBounds(obj);

            if (axis === 'h') {
                // 縦中央 = 水平方向の中央
                obj.x = canvas.width / 2;
            } else if (axis === 'v') {
                // 横中央 = 垂直方向の中央
                obj.y = canvas.height / 2;
            }

            updateLayerProps();
            render();
        }

        // IME入力対応
        imeInput.addEventListener('compositionstart', () => { isComposing = true; });
        imeInput.addEventListener('compositionend', (e) => {
            isComposing = false;
            const text = e.data || imeInput.value;
            if (editingObjId && text) insertText(text);
            imeInput.value = '';
        });
        imeInput.addEventListener('input', (e) => {
            if (!isComposing && editingObjId) {
                const text = e.data || imeInput.value;
                if (text) { insertText(text); imeInput.value = ''; }
            }
        });
        imeInput.addEventListener('blur', (e) => {
            if (editingObjId) {
                // 他の入力要素にフォーカスが移った場合はフォーカスを戻さない
                setTimeout(() => {
                    const active = document.activeElement;
                    if (active && (active.tagName === 'INPUT' || active.tagName === 'SELECT' || active.tagName === 'BUTTON')) {
                        return;
                    }
                    imeInput.focus();
                }, 0);
            }
        });

        function insertText(text) {
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;
            if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                const start = Math.min(selectedCharStart, selectedCharEnd);
                const end = Math.max(selectedCharStart, selectedCharEnd);
                obj.chars.splice(start, end - start);
                cursorPos = start;
                selectedCharStart = -1;
                selectedCharEnd = -1;
            }
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));
            obj.chars.splice(cursorPos, 0, ...chars);
            cursorPos += chars.length;
            render();
            updateLayerList();
            debouncedSaveState();  // テキスト編集のUndo保存
        }

        function getHandleAtPoint(obj, x, y) {
            const bounds = getObjectBounds(obj);
            const handles = [
                { type: 'nw', x: bounds.x, y: bounds.y },
                { type: 'n', x: bounds.x + bounds.w / 2, y: bounds.y },
                { type: 'ne', x: bounds.x + bounds.w, y: bounds.y },
                { type: 'e', x: bounds.x + bounds.w, y: bounds.y + bounds.h / 2 },
                { type: 'se', x: bounds.x + bounds.w, y: bounds.y + bounds.h },
                { type: 's', x: bounds.x + bounds.w / 2, y: bounds.y + bounds.h },
                { type: 'sw', x: bounds.x, y: bounds.y + bounds.h },
                { type: 'w', x: bounds.x, y: bounds.y + bounds.h / 2 }
            ];
            const hs = 8 / scale;
            for (const h of handles) {
                if (Math.abs(x - h.x) < hs && Math.abs(y - h.y) < hs) return h.type;
            }
            return null;
        }

        canvas.addEventListener('mousedown', (e) => {
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            // スポイトモード
            if (pickingColor) {
                pickingColor = false;
                canvas.style.cursor = 'default';
                // キャンバスから色を取得
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const hex = '#' + [pixel[0], pixel[1], pixel[2]].map(c => c.toString(16).padStart(2, '0')).join('');
                document.getElementById('imageTransparentColor').value = hex;
                updateImageTransparency();
                return;
            }

            if (currentTool === 'select') {
                if (selectedObjId && !editingObjId) {
                    const obj = textObjects.find(o => o.id === selectedObjId);
                    if (obj) {
                        // ペンパスの制御点編集をチェック
                        if (obj.type === 'penPath') {
                            const cpInfo = getPenControlPointAt(obj, x, y);
                            if (cpInfo) {
                                saveState();
                                editingControlPoint = cpInfo;
                                editingPenPath = obj.id;
                                return;
                            }
                        }

                        const handle = getHandleAtPoint(obj, x, y);
                        if (handle) {
                            saveState();
                            isResizing = true;
                            resizeHandle = handle;
                            const bounds = getObjectBounds(obj);
                            resizeStart = { x, y, bounds, obj: JSON.parse(JSON.stringify(obj)) };
                            return;
                        }
                    }
                }
                const obj = findObjectAt(x, y);
                if (obj) {
                    // Shift+クリックでない場合、クリックしたオブジェクトが選択されていなければ新規選択
                    if (!e.shiftKey && !selectedObjIds.includes(obj.id)) {
                        saveState();
                        selectObject(obj.id, false);
                    } else if (e.shiftKey) {
                        saveState();
                        selectObject(obj.id, true);
                    }
                    // ドラッグ開始（複数選択時も対応）
                    isDragging = true;
                    dragOffset = { x: x - obj.x, y: y - obj.y };
                    // 複数選択時は各オブジェクトのオフセットを保存
                    if (selectedObjIds.length > 1) {
                        window.multiDragOffsets = {};
                        selectedObjIds.forEach(id => {
                            const o = textObjects.find(t => t.id === id);
                            if (o) window.multiDragOffsets[id] = { x: x - o.x, y: y - o.y };
                        });
                    }
                } else {
                    selectedObjId = null;
                    selectedObjIds = [];
                    updateLayerList();
                    updateLayerProps();
                    render();
                }
            } else if (currentTool === 'text') {
                const obj = findObjectAt(x, y);
                if (editingObjId) {
                    if (obj && obj.id === editingObjId) {
                        const charIdx = getCharIndexAt(obj, x, y);
                        selectedCharStart = charIdx;
                        selectedCharEnd = charIdx;
                        cursorPos = charIdx;
                        isSelecting = true;
                        render();
                    } else {
                        exitEditMode();
                        if (obj) {
                            enterEditMode(obj.id);
                            cursorPos = getCharIndexAt(obj, x, y);
                        } else {
                            createTextObject('', x, y);
                            enterEditMode(textObjects[textObjects.length - 1].id);
                        }
                    }
                } else if (obj) {
                    enterEditMode(obj.id);
                    cursorPos = getCharIndexAt(obj, x, y);
                    render();
                } else {
                    createTextObject('', x, y);
                    enterEditMode(textObjects[textObjects.length - 1].id);
                }
            } else if (currentTool === 'textV') {
                // 縦書きテキスト
                const obj = findObjectAt(x, y);
                if (obj && obj.type === 'text') {
                    enterEditMode(obj.id);
                    cursorPos = getCharIndexAt(obj, x, y);
                    render();
                } else {
                    createTextObject('', x, y, true); // vertical=true
                    enterEditMode(textObjects[textObjects.length - 1].id);
                }
            } else if (currentTool === 'rotate') {
                // 回転ツール
                const obj = findObjectAt(x, y);
                if (obj) {
                    saveState();
                    selectObject(obj.id);
                    isRotating = true;
                    const bounds = getObjectBounds(obj);
                    const cx = obj.x, cy = obj.y;
                    rotateStart = {
                        angle: Math.atan2(y - cy, x - cx),
                        rotation: obj.rotation || 0
                    };
                }
            } else if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(currentTool)) {
                // 図形描画ツール
                isDrawingShape = true;
                shapeStart = { x, y };
                tempShape = {
                    type: currentTool,
                    x1: x, y1: y,
                    x2: x, y2: y
                };
            } else if (currentTool === 'pathText') {
                // パス上文字ツール - ポイント追加（シンプルなポリライン）
                if (!isDrawingPath) {
                    isDrawingPath = true;
                    pathPoints = [{ x, y }];
                } else {
                    pathPoints.push({ x, y });
                }
                render();
            } else if (currentTool === 'pen') {
                // ペンツール - ベジェ曲線対応
                if (!isDrawingPath) {
                    isDrawingPath = true;
                    pathPoints = [{ x, y, cp1: null, cp2: null }];
                } else {
                    pathPoints.push({ x, y, cp1: null, cp2: null });
                }
                penDragging = true;
                penDragStart = { x, y };
                render();
            }
        });

        canvas.addEventListener('dblclick', (e) => {
            // ペンツール - パス完成
            if (currentTool === 'pen' && isDrawingPath && pathPoints.length >= 2) {
                saveState();
                const penObj = createPenObject(pathPoints);
                textObjects.push(penObj);
                selectObject(penObj.id);
                updateLayerList();
                pathPoints = [];
                isDrawingPath = false;
                render();
                return;
            }
            // パス上文字ツール - パス完成
            if (currentTool === 'pathText' && isDrawingPath && pathPoints.length >= 2) {
                const rect = canvas.getBoundingClientRect();
                scale = canvas.width / rect.width;
                const text = prompt('パスに表示するテキストを入力:', 'サンプルテキスト');
                if (text) {
                    saveState();
                    const pathTextObj = createPathTextObject(text, pathPoints);
                    textObjects.push(pathTextObj);
                    selectObject(pathTextObj.id);
                    updateLayerList();
                }
                pathPoints = [];
                isDrawingPath = false;
                render();
                return;
            }

            if (currentTool !== 'select') return;
            const rect = canvas.getBoundingClientRect();
            scale = canvas.width / rect.width;
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;
            const obj = findObjectAt(x, y);
            if (obj) {
                setTool('text');
                enterEditMode(obj.id);
                cursorPos = getCharIndexAt(obj, x, y);
                render();
            }
        });

        canvas.addEventListener('mousemove', (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX - rect.left) * scale;
            const y = (e.clientY - rect.top) * scale;

            if (isResizing && resizeHandle) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const dx = x - resizeStart.x;
                    const dy = y - resizeStart.y;
                    const origBounds = resizeStart.bounds;
                    let sfX = 1, sfY = 1;
                    if (resizeHandle.includes('e')) sfX = (origBounds.w + dx) / origBounds.w;
                    else if (resizeHandle.includes('w')) sfX = (origBounds.w - dx) / origBounds.w;
                    if (resizeHandle.includes('s')) sfY = (origBounds.h + dy) / origBounds.h;
                    else if (resizeHandle.includes('n')) sfY = (origBounds.h - dy) / origBounds.h;
                    if (sfX <= 0) sfX = 0.1;
                    if (sfY <= 0) sfY = 0.1;
                    const origObj = resizeStart.obj;
                    obj.chars.forEach((c, i) => {
                        if (origObj.chars[i]) {
                            c.fontSize = Math.max(1, Math.round(origObj.chars[i].fontSize * sfY));
                            c.scaleX = Math.max(10, Math.round((origObj.chars[i].scaleX || 100) * sfX / sfY));
                        }
                    });
                    render();
                    updateLayerProps();
                }
            } else if (isSelecting && editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (obj) { selectedCharEnd = getCharIndexAt(obj, x, y); render(); }
            } else if (isDragging && selectedObjIds.length > 0) {
                // 複数オブジェクト移動
                if (selectedObjIds.length > 1 && window.multiDragOffsets) {
                    selectedObjIds.forEach(id => {
                        const obj = textObjects.find(o => o.id === id);
                        const offset = window.multiDragOffsets[id];
                        if (obj && offset) {
                            obj.x = x - offset.x;
                            obj.y = y - offset.y;
                        }
                    });
                } else if (selectedObjId) {
                    const obj = textObjects.find(o => o.id === selectedObjId);
                    if (obj) { obj.x = x - dragOffset.x; obj.y = y - dragOffset.y; }
                }
                updateLayerProps();
                render();
            } else if (currentTool === 'select' && selectedObjId && !editingObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const handle = getHandleAtPoint(obj, x, y);
                    if (handle) {
                        const cursors = { nw: 'nw-resize', n: 'n-resize', ne: 'ne-resize', e: 'e-resize', se: 'se-resize', s: 's-resize', sw: 'sw-resize', w: 'w-resize' };
                        canvas.style.cursor = cursors[handle];
                    } else canvas.style.cursor = 'default';
                }
            } else if (isRotating && selectedObjId) {
                // 回転処理
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj) {
                    const cx = obj.x, cy = obj.y;
                    const currentAngle = Math.atan2(y - cy, x - cx);
                    const deltaAngle = (currentAngle - rotateStart.angle) * 180 / Math.PI;
                    obj.rotation = rotateStart.rotation + deltaAngle;
                    updateLayerProps();
                    render();
                }
            } else if (isDrawingShape && tempShape) {
                // 図形プレビュー
                tempShape.x2 = x;
                tempShape.y2 = y;
                render();
            } else if (penDragging && isDrawingPath && pathPoints.length > 0) {
                // ペンツール - ドラッグで制御点を設定
                const lastPoint = pathPoints[pathPoints.length - 1];
                const dx = x - penDragStart.x;
                const dy = y - penDragStart.y;
                // 対称的なベジェハンドルを設定
                lastPoint.cp2 = { x: x, y: y };
                lastPoint.cp1 = { x: penDragStart.x - dx, y: penDragStart.y - dy };
                render();
            } else if (editingControlPoint && editingPenPath) {
                // 制御点のドラッグ編集
                const obj = textObjects.find(o => o.id === editingPenPath);
                if (obj && obj.path) {
                    const point = obj.path[editingControlPoint.pointIndex];
                    const relX = x - obj.x;
                    const relY = y - obj.y;

                    if (editingControlPoint.type === 'anchor') {
                        // アンカーポイントを移動（制御点も一緒に移動）
                        const dx = relX - point.x;
                        const dy = relY - point.y;
                        point.x = relX;
                        point.y = relY;
                        if (point.cp1) {
                            point.cp1.x += dx;
                            point.cp1.y += dy;
                        }
                        if (point.cp2) {
                            point.cp2.x += dx;
                            point.cp2.y += dy;
                        }
                    } else if (editingControlPoint.type === 'cp1') {
                        point.cp1 = { x: relX, y: relY };
                    } else if (editingControlPoint.type === 'cp2') {
                        point.cp2 = { x: relX, y: relY };
                    }
                    render();
                }
            }
        });

        canvas.addEventListener('mouseup', () => {
            isDragging = false;
            isSelecting = false;
            isResizing = false;
            resizeHandle = null;

            // 回転終了
            if (isRotating) {
                isRotating = false;
            }

            // 図形描画完了
            if (isDrawingShape && tempShape) {
                const minSize = 5;
                const w = Math.abs(tempShape.x2 - tempShape.x1);
                const h = Math.abs(tempShape.y2 - tempShape.y1);
                if (w > minSize || h > minSize) {
                    createShapeObject(tempShape);
                }
                isDrawingShape = false;
                tempShape = null;
                render();
            }

            // ペンツール - ドラッグ終了
            if (penDragging) {
                penDragging = false;
                penDragStart = null;
            }

            // 制御点編集終了
            if (editingControlPoint) {
                editingControlPoint = null;
                editingPenPath = null;
            }

            updateCharInfo();
        });

        document.addEventListener('keydown', (e) => {
            // Undo/Redo ショートカット
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undo();
                return;
            }
            if (e.ctrlKey && (e.key === 'y' || (e.shiftKey && e.key === 'Z'))) {
                e.preventDefault();
                redo();
                return;
            }
            // Copy/Paste ショートカット
            if (e.ctrlKey && e.key === 'c' && !editingObjId) {
                e.preventDefault();
                copySelected();
                return;
            }
            if (e.ctrlKey && e.key === 'v' && !editingObjId) {
                e.preventDefault();
                pasteObject();
                return;
            }
            // Delete ショートカット
            if ((e.key === 'Delete' || e.key === 'Backspace') && !editingObjId && selectedObjId) {
                e.preventDefault();
                deleteSelected();
                return;
            }
            // Group ショートカット (Ctrl+G)
            if (e.ctrlKey && e.key === 'g' && !e.shiftKey && !editingObjId) {
                e.preventDefault();
                groupSelected();
                return;
            }
            // Ungroup ショートカット (Ctrl+Shift+G)
            if (e.ctrlKey && e.shiftKey && (e.key === 'g' || e.key === 'G') && !editingObjId) {
                e.preventDefault();
                ungroupSelected();
                return;
            }
            // 矢印キー微調整
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key) && !editingObjId && selectedObjIds.length > 0) {
                e.preventDefault();
                const step = e.shiftKey ? 10 : 1;
                saveState();
                selectedObjIds.forEach(id => {
                    const obj = textObjects.find(o => o.id === id);
                    if (obj) {
                        if (e.key === 'ArrowUp') obj.y -= step;
                        else if (e.key === 'ArrowDown') obj.y += step;
                        else if (e.key === 'ArrowLeft') obj.x -= step;
                        else if (e.key === 'ArrowRight') obj.x += step;
                    }
                });
                updateLayerProps();
                render();
                return;
            }
            // スペースキーで再生/停止
            if (e.key === ' ' && !editingObjId && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                toggleAnimation();
                return;
            }
            if ((e.key === 'v' || e.key === 'V') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('select'); return; }
            if ((e.key === 't' || e.key === 'T') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('text'); return; }
            if ((e.key === 'r' || e.key === 'R') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('rotate'); return; }
            if ((e.key === 'p' || e.key === 'P') && !editingObjId && document.activeElement.tagName !== 'INPUT') { setTool('pen'); return; }
            if (!editingObjId) return;
            if ((e.target.tagName === 'INPUT' && e.target.id !== 'imeInput') || e.target.tagName === 'SELECT') return;
            if (isComposing) return;
            const obj = textObjects.find(o => o.id === editingObjId);
            if (!obj) return;

            if (e.key === 'Backspace') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(s, en - s); cursorPos = s; selectedCharStart = -1; selectedCharEnd = -1;
                } else if (cursorPos > 0) { obj.chars.splice(cursorPos - 1, 1); cursorPos--; }
                render();
                debouncedSaveState();  // テキスト編集のUndo保存
            } else if (e.key === 'Delete') {
                e.preventDefault();
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                    obj.chars.splice(s, en - s); cursorPos = s; selectedCharStart = -1; selectedCharEnd = -1;
                } else if (cursorPos < obj.chars.length) obj.chars.splice(cursorPos, 1);
                render();
                debouncedSaveState();  // テキスト編集のUndo保存
            } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight' || e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                e.preventDefault();
                selectedCharStart = -1;

                if (obj.vertical) {
                    // 縦書き: Up/Downで文字移動、Left/Rightで列移動
                    if (e.key === 'ArrowUp') {
                        if (cursorPos > 0) cursorPos--;
                    } else if (e.key === 'ArrowDown') {
                        if (cursorPos < obj.chars.length) cursorPos++;
                    } else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        // 列移動
                        const lines = getLines(obj);
                        let cCol = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cCol = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        if (e.key === 'ArrowLeft') {
                            // 次の列（右から左なので次の列は左）
                            if (cCol < lines.length - 1) {
                                let newCount = 0;
                                for (let li = 0; li <= cCol; li++) newCount += lines[li].length + 1;
                                cursorPos = Math.min(newCount + cIdx, newCount + lines[cCol + 1].length);
                            }
                        } else {
                            // 前の列
                            if (cCol > 0) {
                                let newCount = 0;
                                for (let li = 0; li < cCol - 1; li++) newCount += lines[li].length + 1;
                                cursorPos = Math.min(newCount + cIdx, newCount + lines[cCol - 1].length);
                            }
                        }
                    }
                } else {
                    // 横書き: Left/Rightで文字移動、Up/Downで行移動
                    if (e.key === 'ArrowLeft') {
                        if (cursorPos > 0) cursorPos--;
                    } else if (e.key === 'ArrowRight') {
                        if (cursorPos < obj.chars.length) cursorPos++;
                    } else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                        // 行移動
                        const lines = getLines(obj);
                        let cLine = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cLine = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        if (e.key === 'ArrowUp' && cLine > 0) {
                            let newCount = 0;
                            for (let li = 0; li < cLine - 1; li++) newCount += lines[li].length + 1;
                            cursorPos = Math.min(newCount + cIdx, newCount + lines[cLine - 1].length);
                        } else if (e.key === 'ArrowDown' && cLine < lines.length - 1) {
                            let newCount = 0;
                            for (let li = 0; li <= cLine; li++) newCount += lines[li].length + 1;
                            cursorPos = Math.min(newCount + cIdx, newCount + lines[cLine + 1].length);
                        }
                    }
                }
                render();
            }
            else if (e.key === 'Escape') {
                if (isDrawingPath) {
                    // Cancel path drawing
                    pathPoints = [];
                    isDrawingPath = false;
                    render();
                } else {
                    exitEditMode();
                    setTool('select');
                }
            }
            else if (e.key === 'Enter') { e.preventDefault(); insertText('\n'); }
            else if (e.key === 'a' && e.ctrlKey) { e.preventDefault(); selectedCharStart = 0; selectedCharEnd = obj.chars.length; render(); updateCharInfo(); }
            else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey) {
                if (document.activeElement === imeInput) return;
                e.preventDefault();
                insertText(e.key);
            }
            updateLayerList();
        });

        function getCharIndexAt(obj, x, y) {
            // パス上文字の場合
            if (obj.type === 'pathText' && obj.path && obj.chars) {
                const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                const pathLen = getPathLength(absPath);
                const totalTextWidth = obj.chars.reduce((w, c) => w + getCharWidth(c), 0);
                let startOffset = 0;
                if (obj.textAlign === 'center') startOffset = (pathLen - totalTextWidth) / 2;
                else if (obj.textAlign === 'right') startOffset = pathLen - totalTextWidth;

                let offset = startOffset;
                for (let i = 0; i < obj.chars.length; i++) {
                    const charW = getCharWidth(obj.chars[i]);
                    const pos = getPointAtDistance(absPath, offset + charW / 2);
                    if (pos) {
                        const dist = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                        if (dist < obj.chars[i].fontSize) {
                            // 文字の前半か後半かで判定
                            const prevPos = getPointAtDistance(absPath, offset);
                            if (prevPos) {
                                const distToPrev = Math.sqrt((x - prevPos.x) ** 2 + (y - prevPos.y) ** 2);
                                const distToCurr = Math.sqrt((x - pos.x) ** 2 + (y - pos.y) ** 2);
                                if (distToPrev < distToCurr) return i;
                            }
                            return i;
                        }
                    }
                    offset += charW;
                }
                return obj.chars.length;
            }

            const lines = getLines(obj);

            // 縦書きの場合
            if (obj.vertical) {
                const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                const totalWidth = lines.length * colWidth;

                let startX = obj.x;
                if (obj.textAlign === 'center') startX = obj.x + totalWidth / 2 - colWidth / 2;
                else if (obj.textAlign === 'left') startX = obj.x + totalWidth - colWidth;

                // 最も近い列を見つける
                let closestCol = 0;
                let closestDist = Infinity;
                for (let li = 0; li < lines.length; li++) {
                    const colX = startX - li * colWidth;
                    const dist = Math.abs(x - colX);
                    if (dist < closestDist) {
                        closestDist = dist;
                        closestCol = li;
                    }
                }

                let ci = 0;
                for (let li = 0; li < closestCol; li++) {
                    ci += lines[li].length + 1;
                }

                const line = lines[closestCol];
                const colX = startX - closestCol * colWidth;
                const lineH = getVerticalLineHeight(line);

                let startY = obj.y;
                if (obj.verticalAlign === 'top') startY = obj.y;
                else if (obj.verticalAlign === 'bottom') startY = obj.y - lineH;
                else startY = obj.y - lineH / 2;

                let py = startY;
                for (let i = 0; i < line.length; i++) {
                    const h = getCharHeight(line[i]);
                    if (y < py + h / 2) return ci + i;
                    py += h;
                }
                return ci + line.length;
            }

            // 横書きの場合
            const lh = getLineHeight(obj) * (obj.lineHeight || 1.2);
            const th = lines.length * lh;
            let startY = obj.y;
            if (obj.verticalAlign === 'top') startY = obj.y;
            else if (obj.verticalAlign === 'bottom') startY = obj.y - th + lh;
            else startY = obj.y - th / 2 + lh / 2;
            let ci = 0;
            for (let li = 0; li < lines.length; li++) {
                const line = lines[li], lineY = startY + li * lh, lw = getLineWidth(line);
                let lx = obj.x;
                if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                else if (obj.textAlign === 'right') lx = obj.x - lw;
                if (y >= lineY - lh / 2 && y < lineY + lh / 2) {
                    let px = lx;
                    for (let i = 0; i < line.length; i++) {
                        const w = getCharWidth(line[i]);
                        if (x < px + w / 2) return ci + i;
                        px += w;
                    }
                    return ci + line.length;
                }
                ci += line.length + 1;
            }
            return obj.chars.length;
        }

        function getLines(obj) {
            const lines = [[]];
            obj.chars.forEach(c => { if (c.char === '\n') lines.push([]); else lines[lines.length - 1].push(c); });
            return lines;
        }

        function getCharWidth(c) {
            const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
            const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
            return ctx.measureText(dc).width * (c.scaleX || 100) / 100 + (c.tracking || 0) + (c.kerning || 0);
        }

        function getLineWidth(line) { return line.reduce((w, c) => w + getCharWidth(c), 0); }
        function getLineHeight(obj) { return Math.max(...obj.chars.map(c => c.fontSize), 72); }

        // Vertical text helpers
        function getCharHeight(c) {
            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
            return fs * (c.lineHeight || 1.2) + (c.tracking || 0);
        }
        function getVerticalLineHeight(line) { return line.reduce((h, c) => h + getCharHeight(c), 0); }
        function getVerticalLineWidth(obj) { return Math.max(...obj.chars.map(c => c.fontSize), 72); }

        function createTextObject(text, x, y, vertical = false) {
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));
            const obj = {
                id: Date.now(),
                type: 'text',
                name: (vertical ? '縦書き ' : 'テキスト ') + (textObjects.length + 1),
                x, y,
                rotation: 0,
                opacity: 100,
                lineHeight: 1.2,
                textAlign: 'left',
                verticalAlign: 'middle',
                vertical: vertical,
                chars,
                // Name tag properties
                nameTag: {
                    enabled: false,
                    text: '',
                    font: 'Yu Gothic UI',
                    position: 'top-left',
                    gap: 10,
                    color: '#ffffff',
                    size: 36,
                    bgEnabled: true,
                    bgShape: 'rounded',
                    bgRadius: 5,
                    bgColor: '#0078d4',
                    bgOpacity: 100,
                    padX: 10,
                    padY: 5,
                    strokeEnabled: false,
                    strokeColor: '#ffffff',
                    strokeWidth: 2
                },
                // Balloon properties
                balloon: {
                    enabled: false,
                    shape: 'rounded',
                    radius: 20,
                    padX: 30,
                    padY: 20,
                    fill: '#ffffff',
                    fillOpacity: 100,
                    strokeEnabled: true,
                    strokeColor: '#000000',
                    strokeWidth: 3,
                    tailEnabled: true,
                    tailDir: 'bottom',
                    tailPos: 50,
                    tailWidth: 20,
                    tailLength: 30
                }
            };
            saveState();
            textObjects.push(obj);
            selectObject(obj.id);
            updateLayerList();
            render();
        }

        function createPathTextObject(text, points) {
            const style = getDefaultStyle();
            const chars = text.split('').map(char => ({ char, ...style }));

            // Calculate bounding box and center
            const xs = points.map(p => p.x), ys = points.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;

            const obj = {
                id: Date.now(),
                type: 'pathText',
                name: 'パス上文字 ' + (textObjects.length + 1),
                x: cx, y: cy,
                rotation: 0,
                opacity: 100,
                chars,
                // Store path points relative to center
                path: points.map(p => ({ x: p.x - cx, y: p.y - cy })),
                pathOffset: 0,  // Offset along path for text start
                vertical: false,  // 縦書きモード
                // Name tag and balloon (disabled for path text)
                nameTag: { enabled: false },
                balloon: { enabled: false }
            };
            return obj;
        }

        function createPenObject(points) {
            // Calculate bounding box and center
            const xs = points.map(p => p.x), ys = points.map(p => p.y);
            const minX = Math.min(...xs), maxX = Math.max(...xs);
            const minY = Math.min(...ys), maxY = Math.max(...ys);
            const cx = (minX + maxX) / 2, cy = (minY + maxY) / 2;

            const obj = {
                id: Date.now(),
                type: 'penPath',
                name: 'パス ' + (textObjects.length + 1),
                x: cx, y: cy,
                width: maxX - minX || 10,
                height: maxY - minY || 10,
                rotation: 0,
                opacity: 100,
                // Store path points relative to center with bezier control points
                // Each point: {x, y, cp1: {x, y}, cp2: {x, y}}
                // cp1: control point for curve coming INTO this point
                // cp2: control point for curve going OUT OF this point
                path: points.map(p => ({
                    x: p.x - cx,
                    y: p.y - cy,
                    cp1: p.cp1 ? { x: p.cp1.x - cx, y: p.cp1.y - cy } : null,
                    cp2: p.cp2 ? { x: p.cp2.x - cx, y: p.cp2.y - cy } : null
                })),
                closed: false,  // 閉じたパス
                // 塗り設定
                fillType: 'none',
                fill: '#ffffff',
                fillOpacity: 100,
                // ストローク設定
                stroke: '#ffffff',
                strokeWidth: 3,
                strokeOpacity: 100
            };
            return obj;
        }

        // Calculate total length of path
        function getPathLength(points) {
            let len = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                len += Math.sqrt(dx * dx + dy * dy);
            }
            return len;
        }

        // Get point and angle at distance along path
        function getPointAtDistance(points, dist) {
            let accumulated = 0;
            for (let i = 1; i < points.length; i++) {
                const dx = points[i].x - points[i-1].x;
                const dy = points[i].y - points[i-1].y;
                const segLen = Math.sqrt(dx * dx + dy * dy);

                if (accumulated + segLen >= dist) {
                    const t = (dist - accumulated) / segLen;
                    return {
                        x: points[i-1].x + dx * t,
                        y: points[i-1].y + dy * t,
                        angle: Math.atan2(dy, dx)
                    };
                }
                accumulated += segLen;
            }
            // Return last point
            const last = points[points.length - 1];
            const prev = points[points.length - 2] || points[0];
            return {
                x: last.x,
                y: last.y,
                angle: Math.atan2(last.y - prev.y, last.x - prev.x)
            };
        }

        function createShapeObject(shape) {
            const x = Math.min(shape.x1, shape.x2);
            const y = Math.min(shape.y1, shape.y2);
            const w = Math.abs(shape.x2 - shape.x1);
            const h = Math.abs(shape.y2 - shape.y1);

            const obj = {
                id: Date.now(),
                type: shape.type,
                name: getShapeName(shape.type) + ' ' + (textObjects.length + 1),
                x: x + w / 2,
                y: y + h / 2,
                width: w,
                height: h,
                rotation: 0,
                opacity: 100,
                // 塗り設定
                fillType: 'solid',  // solid, linear, radial, none
                fill: '#ffffff',
                fillOpacity: 100,
                gradientStops: [
                    { color: '#ffffff', ratio: 50, pos: 0, endPos: 50 },
                    { color: '#888888', ratio: 50, pos: 50, endPos: 100 }
                ],
                gradientAngle: 0,
                // ストローク設定
                stroke: '#000000',
                strokeWidth: 2,
                strokeOpacity: 100,
                cornerRadius: shape.type === 'roundRect' ? 20 : 0
            };

            saveState();
            textObjects.push(obj);
            selectObject(obj.id);
            updateLayerList();
            render();
        }

        function getShapeName(type) {
            const names = {
                rect: '長方形',
                roundRect: '角丸長方形',
                ellipse: '楕円',
                triangle: '三角形',
                line: 'ライン',
                chamferRect: '斜角長方形',
                arc: '円弧'
            };
            return names[type] || '図形';
        }

        function updateNameTag() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            if (!obj.nameTag) obj.nameTag = {};
            obj.nameTag.enabled = document.getElementById('nameTagEnabled').checked;
            obj.nameTag.text = document.getElementById('nameTagText').value;
            obj.nameTag.font = getSelectedFont('nameTagFont', nameTagCustomFont);
            obj.nameTag.position = document.getElementById('nameTagPosition').value;
            obj.nameTag.gap = parseInt(document.getElementById('nameTagGap').value) || 10;
            obj.nameTag.color = document.getElementById('nameTagColor').value;
            obj.nameTag.size = parseInt(document.getElementById('nameTagSize').value) || 36;
            obj.nameTag.bgEnabled = document.getElementById('nameTagBgEnabled').checked;
            obj.nameTag.bgShape = document.getElementById('nameTagBgShape').value;
            obj.nameTag.bgRadius = parseInt(document.getElementById('nameTagBgRadius').value) || 5;
            obj.nameTag.bgColor = document.getElementById('nameTagBgColor').value;
            obj.nameTag.bgOpacity = parseInt(document.getElementById('nameTagBgOpacity').value) || 100;
            obj.nameTag.padX = parseInt(document.getElementById('nameTagPadX').value) || 10;
            obj.nameTag.padY = parseInt(document.getElementById('nameTagPadY').value) || 5;
            obj.nameTag.strokeEnabled = document.getElementById('nameTagStrokeEnabled').checked;
            obj.nameTag.strokeColor = document.getElementById('nameTagStrokeColor').value;
            obj.nameTag.strokeWidth = parseInt(document.getElementById('nameTagStrokeWidth').value) || 2;
            render();
        }

        function updateBalloon() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            if (!obj.balloon) obj.balloon = {};
            obj.balloon.enabled = document.getElementById('balloonEnabled').checked;
            obj.balloon.shape = document.getElementById('balloonShape').value;
            obj.balloon.radius = parseInt(document.getElementById('balloonRadius').value) || 20;
            obj.balloon.padX = parseInt(document.getElementById('balloonPadX').value) || 30;
            obj.balloon.padY = parseInt(document.getElementById('balloonPadY').value) || 20;
            obj.balloon.fill = document.getElementById('balloonFill').value;
            obj.balloon.fillOpacity = parseInt(document.getElementById('balloonFillOpacity').value) || 100;
            obj.balloon.strokeEnabled = document.getElementById('balloonStrokeEnabled').checked;
            obj.balloon.strokeColor = document.getElementById('balloonStrokeColor').value;
            obj.balloon.strokeWidth = parseInt(document.getElementById('balloonStrokeWidth').value) || 3;
            obj.balloon.tailEnabled = document.getElementById('balloonTailEnabled').checked;
            obj.balloon.tailDir = document.getElementById('balloonTailDir').value;
            obj.balloon.tailPos = parseInt(document.getElementById('balloonTailPos').value) || 50;
            obj.balloon.tailWidth = parseInt(document.getElementById('balloonTailWidth').value) || 20;
            obj.balloon.tailLength = parseInt(document.getElementById('balloonTailLength').value) || 30;
            render();
        }

        function updateShapeStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'arc', 'chamferRect'].includes(obj.type)) return;

            obj.fillType = document.getElementById('shapeFillType').value;
            obj.fill = document.getElementById('shapeFill').value;
            obj.fillOpacity = parseInt(document.getElementById('shapeFillOpacity').value) || 100;
            obj.gradientAngle = parseInt(document.getElementById('shapeGradientAngle').value) || 0;

            // Update gradient stops
            const fill2 = document.getElementById('shapeFill2').value;
            obj.gradientStops = [
                { color: obj.fill, ratio: 50, pos: 0, endPos: 50 },
                { color: fill2, ratio: 50, pos: 50, endPos: 100 }
            ];

            obj.stroke = document.getElementById('shapeStroke').value;
            obj.strokeWidth = parseInt(document.getElementById('shapeStrokeWidth').value) || 2;
            obj.strokeOpacity = parseInt(document.getElementById('shapeStrokeOpacity').value) || 100;

            render();
        }

        function loadShapeUI(obj) {
            if (!['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'arc', 'chamferRect'].includes(obj.type)) return;

            document.getElementById('shapeFillType').value = obj.fillType || 'solid';
            document.getElementById('shapeFill').value = obj.fill || '#ffffff';
            document.getElementById('shapeFillOpacity').value = obj.fillOpacity || 100;
            document.getElementById('shapeGradientAngle').value = obj.gradientAngle || 0;

            // Load second gradient color
            if (obj.gradientStops && obj.gradientStops.length >= 2) {
                document.getElementById('shapeFill2').value = obj.gradientStops[1].color;
            } else {
                document.getElementById('shapeFill2').value = '#888888';
            }

            document.getElementById('shapeStroke').value = obj.stroke || '#000000';
            document.getElementById('shapeStrokeWidth').value = obj.strokeWidth || 2;
            document.getElementById('shapeStrokeOpacity').value = obj.strokeOpacity || 100;
        }

        function updatePathTextStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'pathText') return;

            obj.vertical = document.getElementById('pathTextVertical').checked;
            obj.pathOffset = parseInt(document.getElementById('pathTextOffset').value) || 0;

            render();
        }

        function loadPathTextUI(obj) {
            const panel = document.getElementById('pathTextSettings').parentElement.previousElementSibling;
            if (obj.type !== 'pathText') {
                // Hide pathText settings panel
                document.getElementById('pathTextSettings').classList.add('hidden');
                if (panel) panel.classList.add('collapsed');
                return;
            }

            // Show pathText settings panel
            document.getElementById('pathTextSettings').classList.remove('hidden');
            if (panel) panel.classList.remove('collapsed');

            document.getElementById('pathTextVertical').checked = obj.vertical || false;
            document.getElementById('pathTextOffset').value = obj.pathOffset || 0;
        }

        function updatePenPathStyle() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'penPath') return;

            obj.fillType = document.getElementById('penPathFillType').value;
            obj.fill = document.getElementById('penPathFill').value;
            obj.fillOpacity = parseInt(document.getElementById('penPathFillOpacity').value) || 100;
            obj.stroke = document.getElementById('penPathStroke').value;
            obj.strokeWidth = parseInt(document.getElementById('penPathStrokeWidth').value) || 3;
            obj.strokeOpacity = parseInt(document.getElementById('penPathStrokeOpacity').value) || 100;
            obj.closed = document.getElementById('penPathClosed').checked;

            render();
        }

        function loadPenPathUI(obj) {
            const panel = document.getElementById('penPathSettings').parentElement.previousElementSibling;
            if (obj.type !== 'penPath') {
                // Hide penPath settings panel
                document.getElementById('penPathSettings').classList.add('hidden');
                if (panel) panel.classList.add('collapsed');
                return;
            }

            // Show penPath settings panel
            document.getElementById('penPathSettings').classList.remove('hidden');
            if (panel) panel.classList.remove('collapsed');

            document.getElementById('penPathFillType').value = obj.fillType || 'none';
            document.getElementById('penPathFill').value = obj.fill || '#ffffff';
            document.getElementById('penPathFillOpacity').value = obj.fillOpacity || 100;
            document.getElementById('penPathStroke').value = obj.stroke || '#ffffff';
            document.getElementById('penPathStrokeWidth').value = obj.strokeWidth || 3;
            document.getElementById('penPathStrokeOpacity').value = obj.strokeOpacity || 100;
            document.getElementById('penPathClosed').checked = obj.closed || false;
        }

        function loadNameTagUI(obj) {
            if (!obj.nameTag) return;
            document.getElementById('nameTagEnabled').checked = obj.nameTag.enabled || false;
            document.getElementById('nameTagText').value = obj.nameTag.text || '';
            document.getElementById('nameTagFont').value = obj.nameTag.font || 'Yu Gothic UI';
            document.getElementById('nameTagPosition').value = obj.nameTag.position || 'top-left';
            document.getElementById('nameTagGap').value = obj.nameTag.gap || 10;
            document.getElementById('nameTagColor').value = obj.nameTag.color || '#ffffff';
            document.getElementById('nameTagSize').value = obj.nameTag.size || 36;
            document.getElementById('nameTagBgEnabled').checked = obj.nameTag.bgEnabled !== false;
            document.getElementById('nameTagBgShape').value = obj.nameTag.bgShape || 'rounded';
            document.getElementById('nameTagBgRadius').value = obj.nameTag.bgRadius || 5;
            document.getElementById('nameTagBgColor').value = obj.nameTag.bgColor || '#0078d4';
            document.getElementById('nameTagBgOpacity').value = obj.nameTag.bgOpacity || 100;
            document.getElementById('nameTagPadX').value = obj.nameTag.padX || 10;
            document.getElementById('nameTagPadY').value = obj.nameTag.padY || 5;
            document.getElementById('nameTagStrokeEnabled').checked = obj.nameTag.strokeEnabled || false;
            document.getElementById('nameTagStrokeColor').value = obj.nameTag.strokeColor || '#ffffff';
            document.getElementById('nameTagStrokeWidth').value = obj.nameTag.strokeWidth || 2;
        }

        function loadBalloonUI(obj) {
            if (!obj.balloon) return;
            document.getElementById('balloonEnabled').checked = obj.balloon.enabled || false;
            document.getElementById('balloonShape').value = obj.balloon.shape || 'rounded';
            document.getElementById('balloonRadius').value = obj.balloon.radius || 20;
            document.getElementById('balloonPadX').value = obj.balloon.padX || 30;
            document.getElementById('balloonPadY').value = obj.balloon.padY || 20;
            document.getElementById('balloonFill').value = obj.balloon.fill || '#ffffff';
            document.getElementById('balloonFillOpacity').value = obj.balloon.fillOpacity || 100;
            document.getElementById('balloonStrokeEnabled').checked = obj.balloon.strokeEnabled !== false;
            document.getElementById('balloonStrokeColor').value = obj.balloon.strokeColor || '#000000';
            document.getElementById('balloonStrokeWidth').value = obj.balloon.strokeWidth || 3;
            document.getElementById('balloonTailEnabled').checked = obj.balloon.tailEnabled !== false;
            document.getElementById('balloonTailDir').value = obj.balloon.tailDir || 'bottom';
            document.getElementById('balloonTailPos').value = obj.balloon.tailPos || 50;
            document.getElementById('balloonTailWidth').value = obj.balloon.tailWidth || 20;
            document.getElementById('balloonTailLength').value = obj.balloon.tailLength || 30;
        }

        function findObjectAt(x, y) {
            for (let i = textObjects.length - 1; i >= 0; i--) {
                const obj = textObjects[i], b = getObjectBounds(obj);
                // テキスト系オブジェクトは広めの判定領域（30px）
                const margin = (obj.type === 'text' || obj.type === 'pathText' || obj.chars) ? 30 : 10;
                if (x >= b.x - margin && x <= b.x + b.w + margin && y >= b.y - margin && y <= b.y + b.h + margin) return obj;
            }
            return null;
        }

        function getObjectBounds(obj) {
            // グループオブジェクトの場合
            if (obj.type === 'group') {
                return {
                    x: obj.x - obj.width / 2,
                    y: obj.y - obj.height / 2,
                    w: obj.width,
                    h: obj.height
                };
            }

            // 画像オブジェクトの場合
            if (obj.type === 'image') {
                const crop = obj.crop || { left: 0, top: 0, right: 0, bottom: 0 };
                const srcW = obj.originalWidth - crop.left - crop.right;
                const srcH = obj.originalHeight - crop.top - crop.bottom;
                const dstW = obj.width * (srcW / obj.originalWidth);
                const dstH = obj.height * (srcH / obj.originalHeight);
                return {
                    x: obj.x - dstW / 2,
                    y: obj.y - dstH / 2,
                    w: dstW,
                    h: dstH
                };
            }

            // 図形オブジェクトの場合
            if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(obj.type)) {
                return {
                    x: obj.x - obj.width / 2,
                    y: obj.y - obj.height / 2,
                    w: obj.width,
                    h: obj.height
                };
            }

            // パス上文字オブジェクトの場合
            if (obj.type === 'pathText' && obj.path) {
                const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                const xs = absPath.map(p => p.x), ys = absPath.map(p => p.y);
                const maxFs = obj.chars ? Math.max(...obj.chars.map(c => c.fontSize), 72) : 72;
                return {
                    x: Math.min(...xs) - maxFs / 2,
                    y: Math.min(...ys) - maxFs / 2,
                    w: Math.max(...xs) - Math.min(...xs) + maxFs,
                    h: Math.max(...ys) - Math.min(...ys) + maxFs
                };
            }

            if (obj.type === 'penPath' && obj.path) {
                const absPath = obj.path.map(p => ({
                    x: p.x + obj.x,
                    y: p.y + obj.y,
                    cp1: p.cp1 ? { x: p.cp1.x + obj.x, y: p.cp1.y + obj.y } : null,
                    cp2: p.cp2 ? { x: p.cp2.x + obj.x, y: p.cp2.y + obj.y } : null
                }));
                // Include control points in bounds calculation
                const allPoints = [];
                absPath.forEach(p => {
                    allPoints.push({ x: p.x, y: p.y });
                    if (p.cp1) allPoints.push(p.cp1);
                    if (p.cp2) allPoints.push(p.cp2);
                });
                const xs = allPoints.map(p => p.x), ys = allPoints.map(p => p.y);
                const sw = obj.strokeWidth || 3;
                return {
                    x: Math.min(...xs) - sw,
                    y: Math.min(...ys) - sw,
                    w: Math.max(...xs) - Math.min(...xs) + sw * 2,
                    h: Math.max(...ys) - Math.min(...ys) + sw * 2
                };
            }

            // テキストオブジェクトの場合
            if (!obj.chars || obj.chars.length === 0) {
                return { x: obj.x, y: obj.y, w: 10, h: 72 };
            }

            // 縦書きテキストの場合
            if (obj.vertical) {
                const lines = getLines(obj);
                const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                const totalWidth = lines.length * colWidth;

                let maxHeight = 0;
                lines.forEach(l => {
                    const h = getVerticalLineHeight(l);
                    if (h > maxHeight) maxHeight = h;
                });

                // X位置（右から左へ）
                let right = obj.x;
                if (obj.textAlign === 'center') right = obj.x + totalWidth / 2;
                else if (obj.textAlign === 'left') right = obj.x + totalWidth;

                // Y位置
                let top = obj.y;
                if (obj.verticalAlign === 'bottom') top = obj.y - maxHeight;
                else if (obj.verticalAlign === 'middle') top = obj.y - maxHeight / 2;

                return { x: right - totalWidth, y: top, w: totalWidth || 10, h: maxHeight || 72 };
            }

            // 横書きテキストの場合
            const lines = getLines(obj), blh = getLineHeight(obj), lh = blh * (obj.lineHeight || 1.2);
            let mw = 0;
            lines.forEach(l => { const w = getLineWidth(l); if (w > mw) mw = w; });
            const th = lines.length * lh;
            let left = obj.x;
            if (obj.textAlign === 'center') left = obj.x - mw / 2;
            else if (obj.textAlign === 'right') left = obj.x - mw;
            let top = obj.y - lh / 2;
            if (obj.verticalAlign === 'bottom') top = obj.y - th + lh / 2;
            else if (obj.verticalAlign === 'middle') top = obj.y - th / 2;
            return { x: left, y: top, w: mw || 10, h: th || lh };
        }

        function selectObject(id, addToSelection = false) {
            if (addToSelection) {
                // Shift+クリック: 複数選択に追加/削除
                const idx = selectedObjIds.indexOf(id);
                if (idx === -1) {
                    selectedObjIds.push(id);
                } else {
                    selectedObjIds.splice(idx, 1);
                }
                // selectedObjIdは最後に追加したものに設定
                selectedObjId = selectedObjIds.length > 0 ? selectedObjIds[selectedObjIds.length - 1] : null;
            } else {
                // 通常クリック: 単一選択
                selectedObjId = id;
                selectedObjIds = id ? [id] : [];
            }
            updateLayerList();
            updateLayerProps();
            updateCharInfo();
            render();
        }

        function enterEditMode(id) {
            saveState();  // 編集開始前の状態を保存
            editingObjId = id; selectedObjId = id;
            const obj = textObjects.find(o => o.id === id);
            cursorPos = obj ? obj.chars.length : 0;
            cursorVisible = true;
            if (cursorInterval) clearInterval(cursorInterval);
            cursorInterval = setInterval(() => { cursorVisible = !cursorVisible; render(); }, 500);
            imeInput.focus();
            updateLayerList(); updateLayerProps();
        }

        function exitEditMode() {
            flushDebouncedSave();  // 保留中のUndo保存をフラッシュ
            if (editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (obj && obj.chars.length === 0) { textObjects = textObjects.filter(o => o.id !== editingObjId); selectedObjId = null; }
            }
            editingObjId = null; selectedCharStart = -1; selectedCharEnd = -1;
            if (cursorInterval) clearInterval(cursorInterval);
            imeInput.blur(); updateLayerList(); render();
        }

        // ペンパスの制御点を検出
        function getPenControlPointAt(obj, x, y) {
            if (obj.type !== 'penPath' || !obj.path) return null;
            const threshold = 8;

            for (let i = 0; i < obj.path.length; i++) {
                const p = obj.path[i];
                const absX = p.x + obj.x;
                const absY = p.y + obj.y;

                // 制御点1をチェック
                if (p.cp1) {
                    const cp1X = p.cp1.x + obj.x;
                    const cp1Y = p.cp1.y + obj.y;
                    if (Math.abs(x - cp1X) < threshold && Math.abs(y - cp1Y) < threshold) {
                        return { pointIndex: i, type: 'cp1' };
                    }
                }

                // 制御点2をチェック
                if (p.cp2) {
                    const cp2X = p.cp2.x + obj.x;
                    const cp2Y = p.cp2.y + obj.y;
                    if (Math.abs(x - cp2X) < threshold && Math.abs(y - cp2Y) < threshold) {
                        return { pointIndex: i, type: 'cp2' };
                    }
                }

                // アンカーポイントをチェック
                if (Math.abs(x - absX) < threshold && Math.abs(y - absY) < threshold) {
                    return { pointIndex: i, type: 'anchor' };
                }
            }

            return null;
        }

        function applyStyle() {
            // 編集モードで文字選択がある場合：選択範囲のみに適用
            if (editingObjId) {
                const obj = textObjects.find(o => o.id === editingObjId);
                if (!obj || !obj.chars) return;

                // 文字選択がある場合は選択範囲のみ
                if (selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                    const s = Math.min(selectedCharStart, selectedCharEnd);
                    const en = Math.max(selectedCharStart, selectedCharEnd);
                    const style = getDefaultStyle();
                    for (let i = s; i < en; i++) Object.assign(obj.chars[i], style);
                }
                // 文字選択がない場合は全文字に適用
                else {
                    const style = getDefaultStyle();
                    obj.chars.forEach(c => Object.assign(c, style));
                }
                render();
                return;
            }

            // 選択ツールでレイヤーを選択している場合：全文字に適用
            if (selectedObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (!obj || !obj.chars) return;  // テキストオブジェクトでない場合は無視

                const style = getDefaultStyle();
                obj.chars.forEach(c => Object.assign(c, style));
                render();
            }
        }

        function setTextAlign(a) {
            document.querySelectorAll('[data-align]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-align="${a}"]`).classList.add('active');
            if (selectedObjId) { const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.textAlign = a; render(); } }
        }

        function setVerticalAlign(a) {
            document.querySelectorAll('[data-valign]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-valign="${a}"]`).classList.add('active');
            if (selectedObjId) { const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.verticalAlign = a; render(); } }
        }

        function updateCharInfo() {
            const info = document.getElementById('charInfo');
            if (editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                info.textContent = `${Math.abs(selectedCharEnd - selectedCharStart)}文字選択中`;
            } else if (selectedObjId && !editingObjId) {
                const obj = textObjects.find(o => o.id === selectedObjId);
                if (obj && obj.chars) {
                    info.textContent = `レイヤー全体 (${obj.chars.length}文字)`;
                } else {
                    info.textContent = 'テキストオブジェクトを選択してください';
                }
            } else {
                info.textContent = '文字を選択してください';
            }
        }

        function copySelected() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;
            clipboard = JSON.parse(JSON.stringify(obj));
        }

        function pasteObject() {
            if (!clipboard) return;
            saveState();
            const newObj = JSON.parse(JSON.stringify(clipboard));
            newObj.id = Date.now();
            newObj.x += 20;  // オフセット
            newObj.y += 20;
            newObj.name = (newObj.name || 'Object') + ' (コピー)';
            textObjects.push(newObj);
            selectObject(newObj.id);
            updateLayerList();
            render();
        }

        function deleteSelected() {
            if (selectedObjIds.length === 0) return;
            saveState();
            textObjects = textObjects.filter(o => !selectedObjIds.includes(o.id));
            selectedObjId = null;
            selectedObjIds = [];
            editingObjId = null;
            updateLayerList(); updateLayerProps(); render();
        }

        function groupSelected() {
            if (selectedObjIds.length < 2) return;
            saveState();

            // 選択されたオブジェクトを取得
            const objs = textObjects.filter(o => selectedObjIds.includes(o.id));
            if (objs.length < 2) return;

            // バウンディングボックスを計算
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            objs.forEach(obj => {
                const bounds = getObjectBounds(obj);
                minX = Math.min(minX, bounds.x);
                minY = Math.min(minY, bounds.y);
                maxX = Math.max(maxX, bounds.x + bounds.w);
                maxY = Math.max(maxY, bounds.y + bounds.h);
            });

            const cx = (minX + maxX) / 2;
            const cy = (minY + maxY) / 2;

            // グループ内のオブジェクトの位置を相対座標に変換
            const children = objs.map(obj => {
                const clone = JSON.parse(JSON.stringify(obj));
                clone.x = obj.x - cx;
                clone.y = obj.y - cy;
                return clone;
            });

            // グループオブジェクトを作成
            const groupObj = {
                id: Date.now(),
                type: 'group',
                name: 'グループ ' + (textObjects.filter(o => o.type === 'group').length + 1),
                x: cx,
                y: cy,
                width: maxX - minX,
                height: maxY - minY,
                rotation: 0,
                opacity: 100,
                children: children
            };

            // 元のオブジェクトを削除
            textObjects = textObjects.filter(o => !selectedObjIds.includes(o.id));

            // グループを追加
            textObjects.push(groupObj);

            // グループを選択
            selectedObjId = groupObj.id;
            selectedObjIds = [groupObj.id];

            updateLayerList();
            updateLayerProps();
            render();
        }

        function ungroupSelected() {
            if (selectedObjIds.length === 0) return;

            // 選択されたグループオブジェクトを取得
            const groupObjs = textObjects.filter(o => selectedObjIds.includes(o.id) && o.type === 'group');
            if (groupObjs.length === 0) return;

            saveState();

            const newObjIds = [];

            groupObjs.forEach(groupObj => {
                // グループ内のオブジェクトを展開
                if (groupObj.children) {
                    groupObj.children.forEach(child => {
                        const newObj = JSON.parse(JSON.stringify(child));
                        newObj.id = Date.now() + Math.random() * 1000;
                        // 相対座標を絶対座標に戻す
                        newObj.x = child.x + groupObj.x;
                        newObj.y = child.y + groupObj.y;
                        textObjects.push(newObj);
                        newObjIds.push(newObj.id);
                    });
                }
            });

            // グループオブジェクトを削除
            textObjects = textObjects.filter(o => !(selectedObjIds.includes(o.id) && o.type === 'group'));

            // 展開されたオブジェクトを選択
            selectedObjIds = newObjIds;
            selectedObjId = newObjIds.length > 0 ? newObjIds[newObjIds.length - 1] : null;

            updateLayerList();
            updateLayerProps();
            render();
        }

        function moveLayerUp() {
            if (!selectedObjId) return;
            const idx = textObjects.findIndex(o => o.id === selectedObjId);
            if (idx < textObjects.length - 1) { saveState(); [textObjects[idx], textObjects[idx + 1]] = [textObjects[idx + 1], textObjects[idx]]; updateLayerList(); render(); }
        }

        function moveLayerDown() {
            if (!selectedObjId) return;
            const idx = textObjects.findIndex(o => o.id === selectedObjId);
            if (idx > 0) { saveState(); [textObjects[idx], textObjects[idx - 1]] = [textObjects[idx - 1], textObjects[idx]]; updateLayerList(); render(); }
        }

        function updateLayerName() { if (!selectedObjId) return; const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.name = document.getElementById('layerName').value; updateLayerList(); } }
        function updateLayerPosition() { if (!selectedObjId) return; const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.x = parseFloat(document.getElementById('layerX').value) || 0; obj.y = parseFloat(document.getElementById('layerY').value) || 0; render(); } }
        function updateLayerRotation() { if (!selectedObjId) return; const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.rotation = parseFloat(document.getElementById('layerRotation').value) || 0; render(); } }
        function updateLayerLineHeight() { if (!selectedObjId) return; const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.lineHeight = parseFloat(document.getElementById('layerLineHeight').value) || 1.2; render(); } }
        function updateLayerOpacity() { if (!selectedObjId) return; const obj = textObjects.find(o => o.id === selectedObjId); if (obj) { obj.opacity = parseInt(document.getElementById('layerOpacity').value); document.getElementById('opacityVal').textContent = obj.opacity; render(); } }

        function updateLayerSize() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.chars.length) return;
            const bounds = getObjectBounds(obj);
            const newW = parseFloat(document.getElementById('layerWidth').value) || bounds.w;
            const newH = parseFloat(document.getElementById('layerHeight').value) || bounds.h;
            const sfX = newW / bounds.w, sfY = newH / bounds.h;
            obj.chars.forEach(c => {
                c.fontSize = Math.max(1, Math.round(c.fontSize * sfY));
                c.scaleX = Math.max(10, Math.round((c.scaleX || 100) * sfX / sfY));
            });
            render();
        }

        function updateLayerProps() {
            const propsDiv = document.getElementById('layerProps');
            if (!selectedObjId) { propsDiv.style.display = 'none'; return; }
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) { propsDiv.style.display = 'none'; return; }
            propsDiv.style.display = 'block';
            const bounds = getObjectBounds(obj);
            document.getElementById('layerName').value = obj.name || '';
            document.getElementById('layerX').value = obj.x.toFixed(1);
            document.getElementById('layerY').value = obj.y.toFixed(1);
            document.getElementById('layerWidth').value = bounds.w.toFixed(1);
            document.getElementById('layerHeight').value = bounds.h.toFixed(1);
            document.getElementById('layerRotation').value = obj.rotation || 0;
            document.getElementById('layerLineHeight').value = obj.lineHeight || 1.2;
            document.getElementById('layerOpacity').value = obj.opacity || 100;
            document.getElementById('opacityVal').textContent = obj.opacity || 100;
            document.querySelectorAll('[data-align]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-align="${obj.textAlign || 'left'}"]`)?.classList.add('active');
            document.querySelectorAll('[data-valign]').forEach(b => b.classList.remove('active'));
            document.querySelector(`[data-valign="${obj.verticalAlign || 'middle'}"]`)?.classList.add('active');
            // Load name tag, balloon, shape, pathText, and penPath UI
            loadNameTagUI(obj);
            loadBalloonUI(obj);
            loadShapeUI(obj);
            loadPathTextUI(obj);
            loadPenPathUI(obj);

            // テキストオブジェクトの場合、文字スタイルUIを更新
            if (obj.chars && obj.chars.length > 0) {
                loadCharStyleUI(obj);
            }

            // 画像オブジェクトの場合、画像設定UIを更新
            loadImageUI(obj);

            // アニメーション設定UIを更新
            loadAnimationUI(obj);
        }

        // テキストオブジェクト選択時に文字スタイルUIを更新
        function loadCharStyleUI(obj) {
            if (!obj.chars || obj.chars.length === 0) return;

            // 最初の文字のスタイルを取得（または全文字が同じなら共通値）
            const firstChar = obj.chars[0];

            // フォント
            const fontSel = document.getElementById('fontFamily');
            const customInput = document.getElementById('customFontInput');
            const fontValue = firstChar.fontFamily || 'Yu Gothic UI';
            if ([...fontSel.options].some(opt => opt.value === fontValue)) {
                fontSel.value = fontValue;
                customInput.style.display = 'none';
            } else {
                fontSel.value = '__custom__';
                customInput.value = fontValue;
                customInput.style.display = 'block';
            }

            // サイズ
            document.getElementById('fontSize').value = firstChar.fontSize || 72;

            // 縦横比
            document.getElementById('charScaleX').value = firstChar.scaleX || 100;

            // カーニング・トラッキング
            document.getElementById('charKerning').value = firstChar.kerning || 0;
            document.getElementById('charTracking').value = firstChar.tracking || 0;

            // ベースライン・傾き
            document.getElementById('charBaseline').value = firstChar.baseline || 0;
            document.getElementById('charSlant').value = firstChar.slant || 0;

            // 不透明度
            document.getElementById('charOpacity').value = firstChar.opacity || 100;

            // スモールキャップス
            document.getElementById('charSmallCaps').checked = firstChar.smallCaps || false;
            document.getElementById('charSmallCapsSize').value = firstChar.smallCapsSize || 70;

            // 塗り
            document.getElementById('fillType').value = firstChar.fillType || 'solid';

            // グラデーションストップ
            if (firstChar.gradientStops && firstChar.gradientStops.length >= 2) {
                const stops = document.querySelectorAll('#gradientStops .gradient-stop');
                if (stops.length >= 2) {
                    stops[0].querySelector('.grad-color').value = firstChar.gradientStops[0].color;
                    stops[0].querySelector('.grad-ratio').value = firstChar.gradientStops[0].ratio || 50;
                    stops[1].querySelector('.grad-color').value = firstChar.gradientStops[1].color;
                    stops[1].querySelector('.grad-ratio').value = firstChar.gradientStops[1].ratio || 50;
                }
            } else {
                const stops = document.querySelectorAll('#gradientStops .gradient-stop');
                if (stops.length >= 2) {
                    stops[0].querySelector('.grad-color').value = firstChar.color || '#ffffff';
                }
            }

            document.getElementById('gradientAngle').value = firstChar.gradientAngle || 0;
            document.getElementById('gradientBlur').value = firstChar.gradientBlur || 0;

            // 光沢
            document.getElementById('glossEnabled').checked = firstChar.gloss?.enabled || false;
            document.getElementById('glossWidth').value = firstChar.gloss?.width || 10;
            document.getElementById('glossBlur').value = firstChar.gloss?.blur || 5;
            document.getElementById('glossColor').value = firstChar.gloss?.color || '#ffffff';
            document.getElementById('glossOpacity').value = firstChar.gloss?.opacity || 50;

            // 影
            document.getElementById('shadowEnabled').checked = firstChar.shadow?.enabled || false;
            document.getElementById('shadowColor').value = firstChar.shadow?.color || '#000000';
            document.getElementById('shadowOpacity').value = firstChar.shadow?.opacity || 50;
            document.getElementById('shadowAngle').value = firstChar.shadow?.angle || 45;
            document.getElementById('shadowDistance').value = firstChar.shadow?.distance || 5;
            document.getElementById('shadowSize').value = firstChar.shadow?.size || 0;
            document.getElementById('shadowBlur').value = firstChar.shadow?.blur || 5;

            // ストローク
            loadStrokeUI(firstChar.strokes);
        }

        // ストロークUIを更新
        function loadStrokeUI(strokes) {
            const list = document.getElementById('strokeList');
            list.innerHTML = '';

            const strokesData = strokes || [{ enabled: true, type: 'edge', color: '#000000', width: 4, opacity: 100, join: 'round' }];

            strokesData.forEach((st, i) => {
                const div = document.createElement('div');
                div.className = 'stroke-item';
                div.innerHTML = `
                    <div class="stroke-header">
                        <label><input type="checkbox" class="stroke-enabled" ${st.enabled ? 'checked' : ''} onchange="applyStyle()"> ストローク${i + 1}</label>
                        <button class="btn btn-small btn-danger" onclick="this.parentElement.parentElement.remove();applyStyle()">×</button>
                    </div>
                    <div class="row2">
                        <div><label>種類</label><select class="stroke-type" onchange="applyStyle()">
                            <option value="edge" ${st.type === 'edge' ? 'selected' : ''}>エッジ</option>
                            <option value="depth" ${st.type === 'depth' ? 'selected' : ''}>奥行き</option>
                            <option value="drop" ${st.type === 'drop' ? 'selected' : ''}>ドロップ</option>
                        </select></div>
                        <div><label>色</label><input type="color" class="stroke-color" value="${st.color || '#000000'}" onchange="applyStyle()"></div>
                    </div>
                    <div class="row2">
                        <div><label>太さ</label><input type="number" class="stroke-width" value="${st.width || 4}" min="0" max="50" onchange="applyStyle()"></div>
                        <div><label>不透明度%</label><input type="number" class="stroke-opacity" value="${st.opacity || 100}" min="0" max="100" onchange="applyStyle()"></div>
                    </div>
                    <div class="row2">
                        <div><label>角度°</label><input type="number" class="stroke-angle" value="${st.angle || 45}" step="1" onchange="applyStyle()"></div>
                        <div><label>角</label><select class="stroke-join" onchange="applyStyle()">
                            <option value="round" ${st.join === 'round' ? 'selected' : ''}>丸み</option>
                            <option value="miter" ${st.join === 'miter' ? 'selected' : ''}>角</option>
                            <option value="bevel" ${st.join === 'bevel' ? 'selected' : ''}>面取り</option>
                        </select></div>
                    </div>
                `;
                list.appendChild(div);
            });
        }

        function updateLayerList() {
            const list = document.getElementById('layerList');
            list.innerHTML = '';
            textObjects.slice().reverse().forEach(obj => {
                const div = document.createElement('div');
                const isSelected = selectedObjIds.includes(obj.id);
                div.className = 'layer-item' + (isSelected ? ' selected' : '');

                // グループオブジェクトの表示
                if (obj.type === 'group') {
                    div.textContent = '📁 ' + (obj.name || 'グループ');
                } else {
                    div.textContent = obj.name || (obj.chars ? obj.chars.map(c => c.char).join('').substring(0, 10) : 'オブジェクト');
                }

                div.onclick = (e) => { exitEditMode(); selectObject(obj.id, e.shiftKey); };
                div.ondblclick = () => {
                    if (obj.type === 'group') {
                        // グループをダブルクリックで選択解除してグループ内を選択
                    } else if (obj.type === 'text' || obj.type === 'pathText') {
                        setTool('text');
                        enterEditMode(obj.id);
                    }
                };
                list.appendChild(div);
            });
        }

        function drawRoundedRect(ctx, x, y, w, h, r) {
            r = Math.min(r, w / 2, h / 2);
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + r);
            ctx.lineTo(x + w, y + h - r);
            ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            ctx.lineTo(x + r, y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - r);
            ctx.lineTo(x, y + r);
            ctx.quadraticCurveTo(x, y, x + r, y);
            ctx.closePath();
        }

        function drawShape(ctx, obj) {
            const hw = obj.width / 2;
            const hh = obj.height / 2;

            ctx.save();

            // 塗りつぶし
            const fillType = obj.fillType || 'solid';
            if (fillType !== 'none' && obj.fillOpacity > 0) {
                ctx.globalAlpha = (obj.fillOpacity || 100) / 100;

                // グラデーション設定
                if (fillType === 'linear' || fillType === 'radial') {
                    let grad;
                    if (fillType === 'linear') {
                        const a = (obj.gradientAngle || 0) * Math.PI / 180;
                        const dx = Math.cos(a) * hw, dy = Math.sin(a) * hh;
                        grad = ctx.createLinearGradient(obj.x - dx, obj.y - dy, obj.x + dx, obj.y + dy);
                    } else {
                        grad = ctx.createRadialGradient(obj.x, obj.y, 0, obj.x, obj.y, Math.max(hw, hh));
                    }

                    // グラデーションストップ
                    if (obj.gradientStops && obj.gradientStops.length >= 2) {
                        obj.gradientStops.forEach((stop, i) => {
                            if (i === 0) {
                                grad.addColorStop(0, stop.color);
                            } else if (i === obj.gradientStops.length - 1) {
                                grad.addColorStop(1, stop.color);
                            } else {
                                grad.addColorStop(stop.pos / 100, stop.color);
                            }
                        });
                    } else {
                        grad.addColorStop(0, obj.fill || '#ffffff');
                        grad.addColorStop(1, '#888888');
                    }
                    ctx.fillStyle = grad;
                } else {
                    ctx.fillStyle = obj.fill || '#ffffff';
                }

                if (obj.type === 'rect') {
                    ctx.fillRect(obj.x - hw, obj.y - hh, obj.width, obj.height);
                } else if (obj.type === 'roundRect') {
                    drawRoundedRect(ctx, obj.x - hw, obj.y - hh, obj.width, obj.height, obj.cornerRadius || 20);
                    ctx.fill();
                } else if (obj.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(obj.x, obj.y, hw, hh, 0, 0, Math.PI * 2);
                    ctx.fill();
                } else if (obj.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh);
                    ctx.closePath();
                    ctx.fill();
                } else if (obj.type === 'chamferRect') {
                    const c = Math.min(obj.cornerRadius || 10, hw, hh);
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw + c, obj.y - hh);
                    ctx.lineTo(obj.x + hw - c, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y - hh + c);
                    ctx.lineTo(obj.x + hw, obj.y + hh - c);
                    ctx.lineTo(obj.x + hw - c, obj.y + hh);
                    ctx.lineTo(obj.x - hw + c, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh - c);
                    ctx.lineTo(obj.x - hw, obj.y - hh + c);
                    ctx.closePath();
                    ctx.fill();
                } else if (obj.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + hh, Math.min(hw, hh * 2), Math.PI, 0);
                    ctx.fill();
                }
            }

            // 縁取り
            if (obj.stroke && obj.strokeWidth > 0 && obj.strokeOpacity > 0) {
                ctx.globalAlpha = (obj.strokeOpacity || 100) / 100;
                ctx.strokeStyle = obj.stroke;
                ctx.lineWidth = obj.strokeWidth;

                if (obj.type === 'rect') {
                    ctx.strokeRect(obj.x - hw, obj.y - hh, obj.width, obj.height);
                } else if (obj.type === 'roundRect') {
                    drawRoundedRect(ctx, obj.x - hw, obj.y - hh, obj.width, obj.height, obj.cornerRadius || 20);
                    ctx.stroke();
                } else if (obj.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(obj.x, obj.y, hw, hh, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (obj.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh);
                    ctx.closePath();
                    ctx.stroke();
                } else if (obj.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y + hh);
                    ctx.stroke();
                } else if (obj.type === 'chamferRect') {
                    const c = Math.min(obj.cornerRadius || 10, hw, hh);
                    ctx.beginPath();
                    ctx.moveTo(obj.x - hw + c, obj.y - hh);
                    ctx.lineTo(obj.x + hw - c, obj.y - hh);
                    ctx.lineTo(obj.x + hw, obj.y - hh + c);
                    ctx.lineTo(obj.x + hw, obj.y + hh - c);
                    ctx.lineTo(obj.x + hw - c, obj.y + hh);
                    ctx.lineTo(obj.x - hw + c, obj.y + hh);
                    ctx.lineTo(obj.x - hw, obj.y + hh - c);
                    ctx.lineTo(obj.x - hw, obj.y - hh + c);
                    ctx.closePath();
                    ctx.stroke();
                } else if (obj.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(obj.x, obj.y + hh, Math.min(hw, hh * 2), Math.PI, 0);
                    ctx.stroke();
                }
            }

            ctx.restore();
        }

        function drawBalloon(ctx, obj, bounds) {
            const b = obj.balloon;
            if (!b || !b.enabled) return;

            const padX = b.padX || 30;
            const padY = b.padY || 20;
            const bx = bounds.x - padX;
            const by = bounds.y - padY;
            const bw = bounds.w + padX * 2;
            const bh = bounds.h + padY * 2;
            const radius = b.radius || 20;

            ctx.save();

            // Calculate tail points
            let tailPoints = null;
            if (b.tailEnabled) {
                const tailWidth = b.tailWidth || 20;
                const tailLength = b.tailLength || 30;
                const tailPos = (b.tailPos || 50) / 100;
                const tailDir = b.tailDir || 'bottom';

                let tx, ty, t1x, t1y, t2x, t2y, tipX, tipY;

                if (tailDir === 'bottom' || tailDir === 'bottom-left' || tailDir === 'bottom-right') {
                    tx = bx + bw * tailPos;
                    ty = by + bh;
                    t1x = tx - tailWidth / 2;
                    t2x = tx + tailWidth / 2;
                    t1y = t2y = ty;
                    tipX = tailDir === 'bottom-left' ? tx - tailLength : (tailDir === 'bottom-right' ? tx + tailLength : tx);
                    tipY = ty + tailLength;
                } else if (tailDir === 'top') {
                    tx = bx + bw * tailPos;
                    ty = by;
                    t1x = tx - tailWidth / 2;
                    t2x = tx + tailWidth / 2;
                    t1y = t2y = ty;
                    tipX = tx;
                    tipY = ty - tailLength;
                } else if (tailDir === 'left') {
                    tx = bx;
                    ty = by + bh * tailPos;
                    t1y = ty - tailWidth / 2;
                    t2y = ty + tailWidth / 2;
                    t1x = t2x = tx;
                    tipX = tx - tailLength;
                    tipY = ty;
                } else { // right
                    tx = bx + bw;
                    ty = by + bh * tailPos;
                    t1y = ty - tailWidth / 2;
                    t2y = ty + tailWidth / 2;
                    t1x = t2x = tx;
                    tipX = tx + tailLength;
                    tipY = ty;
                }
                tailPoints = { t1x, t1y, t2x, t2y, tipX, tipY, dir: tailDir };
            }

            // For rounded rectangle, draw body and tail as single unified path
            if (b.shape !== 'ellipse' && b.shape !== 'cloud') {
                const r = Math.min(radius, bw / 2, bh / 2);

                ctx.beginPath();
                ctx.moveTo(bx + r, by);

                // Top edge
                if (tailPoints && tailPoints.dir === 'top') {
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                }
                ctx.lineTo(bx + bw - r, by);
                ctx.quadraticCurveTo(bx + bw, by, bx + bw, by + r);

                // Right edge
                if (tailPoints && tailPoints.dir === 'right') {
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                }
                ctx.lineTo(bx + bw, by + bh - r);
                ctx.quadraticCurveTo(bx + bw, by + bh, bx + bw - r, by + bh);

                // Bottom edge
                if (tailPoints && (tailPoints.dir === 'bottom' || tailPoints.dir === 'bottom-left' || tailPoints.dir === 'bottom-right')) {
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                }
                ctx.lineTo(bx + r, by + bh);
                ctx.quadraticCurveTo(bx, by + bh, bx, by + bh - r);

                // Left edge
                if (tailPoints && tailPoints.dir === 'left') {
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t1x, tailPoints.t1y);
                }
                ctx.lineTo(bx, by + r);
                ctx.quadraticCurveTo(bx, by, bx + r, by);
                ctx.closePath();

                // Fill
                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                // Stroke
                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    ctx.stroke();
                }
            } else if (b.shape === 'ellipse') {
                // Ellipse shape
                ctx.beginPath();
                ctx.ellipse(bx + bw / 2, by + bh / 2, bw / 2, bh / 2, 0, 0, Math.PI * 2);
                ctx.closePath();

                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                // Draw tail separately for ellipse
                if (tailPoints) {
                    ctx.beginPath();
                    ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.closePath();
                    ctx.fill();
                }

                // Stroke
                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    ctx.beginPath();
                    ctx.ellipse(bx + bw / 2, by + bh / 2, bw / 2, bh / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();

                    if (tailPoints) {
                        ctx.beginPath();
                        ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                        ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                        ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                        ctx.stroke();
                    }
                }
            } else {
                // Cloud shape
                const cx = bx + bw / 2, cy = by + bh / 2;
                const rx = bw / 2, ry = bh / 2;
                const bumps = 8;

                ctx.beginPath();
                for (let i = 0; i < bumps; i++) {
                    const angle = (i / bumps) * Math.PI * 2;
                    const px = cx + Math.cos(angle) * rx * 0.8;
                    const py = cy + Math.sin(angle) * ry * 0.8;
                    const bumpR = Math.min(rx, ry) * 0.4;
                    if (i === 0) ctx.moveTo(px + bumpR, py);
                    ctx.arc(px, py, bumpR, 0, Math.PI * 2);
                }
                ctx.closePath();

                ctx.globalAlpha = (b.fillOpacity || 100) / 100;
                ctx.fillStyle = b.fill || '#ffffff';
                ctx.fill();

                if (tailPoints) {
                    ctx.beginPath();
                    ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                    ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                    ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                    ctx.closePath();
                    ctx.fill();
                }

                if (b.strokeEnabled) {
                    ctx.strokeStyle = b.strokeColor || '#000000';
                    ctx.lineWidth = b.strokeWidth || 3;
                    for (let i = 0; i < bumps; i++) {
                        const angle = (i / bumps) * Math.PI * 2;
                        const px = cx + Math.cos(angle) * rx * 0.8;
                        const py = cy + Math.sin(angle) * ry * 0.8;
                        const bumpR = Math.min(rx, ry) * 0.4;
                        ctx.beginPath();
                        ctx.arc(px, py, bumpR, 0, Math.PI * 2);
                        ctx.stroke();
                    }

                    if (tailPoints) {
                        ctx.beginPath();
                        ctx.moveTo(tailPoints.t1x, tailPoints.t1y);
                        ctx.lineTo(tailPoints.tipX, tailPoints.tipY);
                        ctx.lineTo(tailPoints.t2x, tailPoints.t2y);
                        ctx.stroke();
                    }
                }
            }

            ctx.restore();
        }

        // グループ内テキスト描画用のヘルパー関数
        function drawTextObject(ctx, obj) {
            if (!obj.chars || obj.chars.length === 0) return;

            const lines = getLines(obj);
            const lh = getLineHeight(obj) * (obj.lineHeight || 1.2);
            const th = lines.length * lh;
            let startY = obj.y - th / 2 + lh / 2;

            lines.forEach((line, li) => {
                const lw = getLineWidth(line);
                let lx = obj.x;
                if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                else if (obj.textAlign === 'right') lx = obj.x - lw;

                const ly = startY + li * lh;
                let px = lx;

                line.forEach(c => {
                    const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                    const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
                    const charW = getCharWidth(c);

                    ctx.save();
                    const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                    ctx.textBaseline = 'middle';
                    ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;

                    // ストローク
                    const strokes = c.strokes || [{ enabled: true, color: '#000', width: 4, opacity: 100 }];
                    strokes.slice().reverse().forEach(st => {
                        if (!st.enabled) return;
                        ctx.save();
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                        ctx.strokeStyle = st.color;
                        ctx.lineWidth = st.width * 2;
                        ctx.lineJoin = 'round';
                        ctx.strokeText(dc, px + charW / 2, ly);
                        ctx.restore();
                    });

                    // 塗り
                    if (c.fillType !== 'none') {
                        ctx.fillStyle = c.color || '#ffffff';
                        ctx.fillText(dc, px + charW / 2, ly);
                    }

                    ctx.restore();
                    px += charW;
                });
            });
        }

        function drawNameTag(ctx, obj, bounds) {
            const nt = obj.nameTag;
            if (!nt || !nt.enabled || !nt.text) return;

            const fontSize = nt.size || 36;
            const fontFamily = nt.font || 'Yu Gothic UI';
            const padX = nt.padX || 10;
            const padY = nt.padY || 5;
            const gap = nt.gap || 10;
            const isVertical = obj.vertical || false;  // 親オブジェクトが縦書きかどうか

            ctx.save();
            ctx.font = `bold ${fontSize}px "${fontFamily}"`;

            let textWidth, textHeight, bgW, bgH;

            if (isVertical) {
                // 縦書き: 幅は1文字分、高さは文字数×フォントサイズ
                textWidth = fontSize;
                textHeight = nt.text.length * fontSize * 1.1;
                bgW = textWidth + padX * 2;
                bgH = textHeight + padY * 2;
            } else {
                // 横書き
                textWidth = ctx.measureText(nt.text).width;
                textHeight = fontSize;
                bgW = textWidth + padX * 2;
                bgH = textHeight + padY * 2;
            }

            // Calculate position based on position setting
            let nx, ny;
            const pos = nt.position || 'top-left';

            if (isVertical) {
                // 縦書きの場合の位置計算
                if (pos.includes('left')) {
                    nx = bounds.x - gap - bgW;
                } else if (pos.includes('right')) {
                    nx = bounds.x + bounds.w + gap;
                } else {
                    nx = bounds.x + (bounds.w - bgW) / 2;
                }

                if (pos.includes('top')) {
                    ny = bounds.y;
                } else if (pos.includes('bottom')) {
                    ny = bounds.y + bounds.h - bgH;
                } else {
                    ny = bounds.y + (bounds.h - bgH) / 2;
                }
            } else {
                // 横書きの場合の位置計算
                if (pos.includes('left')) {
                    nx = bounds.x;
                } else if (pos.includes('right')) {
                    nx = bounds.x + bounds.w - bgW;
                } else {
                    nx = bounds.x + (bounds.w - bgW) / 2;
                }

                if (pos.includes('top')) {
                    ny = bounds.y - gap - bgH;
                } else {
                    ny = bounds.y + bounds.h + gap;
                }
            }

            // Draw background
            if (nt.bgEnabled) {
                ctx.globalAlpha = (nt.bgOpacity || 100) / 100;

                let radius = nt.bgRadius || 5;
                if (nt.bgShape === 'pill') {
                    radius = Math.min(bgW, bgH) / 2;
                } else if (nt.bgShape === 'rect') {
                    radius = 0;
                }

                drawRoundedRect(ctx, nx, ny, bgW, bgH, radius);
                ctx.fillStyle = nt.bgColor || '#0078d4';
                ctx.fill();

                // Background stroke
                if (nt.strokeEnabled) {
                    ctx.strokeStyle = nt.strokeColor || '#ffffff';
                    ctx.lineWidth = nt.strokeWidth || 2;
                    ctx.stroke();
                }
            }

            // Draw text
            ctx.globalAlpha = 1;
            ctx.fillStyle = nt.color || '#ffffff';

            if (isVertical) {
                // 縦書きテキスト描画
                ctx.textBaseline = 'middle';
                ctx.textAlign = 'center';
                const chars = nt.text.split('');
                const charHeight = fontSize * 1.1;
                const startY = ny + padY + charHeight / 2;
                const centerX = nx + bgW / 2;

                chars.forEach((char, i) => {
                    ctx.fillText(char, centerX, startY + i * charHeight);
                });
            } else {
                // 横書きテキスト描画
                ctx.textBaseline = 'top';
                ctx.fillText(nt.text, nx + padX, ny + padY);
            }

            ctx.restore();
        }

        function render() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 背景描画
            drawBackground(ctx);

            textObjects.forEach(obj => {
                ctx.save();

                // アニメーションプロパティを取得
                const animProps = getAnimatedProperties(obj);
                const animX = animProps.x;
                const animY = animProps.y;
                const animOpacity = animProps.opacity;
                const visibleChars = animProps.visibleChars;
                const charAnimations = animProps.charAnimations;

                // 一時的に位置と不透明度を変更
                const origX = obj.x, origY = obj.y;
                obj.x = animX;
                obj.y = animY;

                ctx.globalAlpha = animOpacity / 100;
                if (obj.rotation) { ctx.translate(obj.x, obj.y); ctx.rotate(obj.rotation * Math.PI / 180); ctx.translate(-obj.x, -obj.y); }

                // タイプライター効果と文字アニメーション用に保存
                obj._visibleChars = visibleChars;
                obj._charAnimations = charAnimations;

                // キーフレーム補間を適用
                const kfProps = interpolateKeyframes(obj);
                if (kfProps) {
                    obj._keyframeProps = kfProps;
                } else {
                    obj._keyframeProps = null;
                }

                // グループオブジェクトの描画
                if (obj.type === 'group' && obj.children) {
                    ctx.save();
                    // グループの子オブジェクトを描画
                    obj.children.forEach(child => {
                        const absChild = {
                            ...child,
                            x: child.x + obj.x,
                            y: child.y + obj.y
                        };
                        ctx.save();
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (child.opacity || 100) / 100;
                        if (child.rotation) {
                            ctx.translate(absChild.x, absChild.y);
                            ctx.rotate(child.rotation * Math.PI / 180);
                            ctx.translate(-absChild.x, -absChild.y);
                        }
                        // 子オブジェクトのタイプに応じて描画
                        if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(child.type)) {
                            drawShape(ctx, absChild);
                        } else if (child.type === 'penPath' && child.path) {
                            // ペンパスの描画（簡易版）
                            const absPath = child.path.map(p => ({
                                x: p.x + absChild.x,
                                y: p.y + absChild.y,
                                cp1: p.cp1 ? { x: p.cp1.x + absChild.x, y: p.cp1.y + absChild.y } : null,
                                cp2: p.cp2 ? { x: p.cp2.x + absChild.x, y: p.cp2.y + absChild.y } : null
                            }));
                            ctx.beginPath();
                            ctx.moveTo(absPath[0].x, absPath[0].y);
                            for (let i = 1; i < absPath.length; i++) {
                                const prev = absPath[i - 1];
                                const curr = absPath[i];
                                if (prev.cp2 || curr.cp1) {
                                    const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                                    const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                                } else {
                                    ctx.lineTo(curr.x, curr.y);
                                }
                            }
                            if (child.closed) ctx.closePath();
                            if (child.fillType !== 'none') {
                                ctx.fillStyle = child.fill || '#ffffff';
                                ctx.fill();
                            }
                            ctx.strokeStyle = child.stroke || '#ffffff';
                            ctx.lineWidth = child.strokeWidth || 3;
                            ctx.stroke();
                        } else if (child.chars) {
                            // テキストオブジェクトの描画
                            drawTextObject(ctx, absChild);
                        }
                        ctx.restore();
                    });
                    ctx.restore();

                    // グループの選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const hw = obj.width / 2, hh = obj.height / 2;
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(obj.x - hw - 5, obj.y - hh - 5, obj.width + 10, obj.height + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: obj.x - hw, y: obj.y - hh }, { x: obj.x, y: obj.y - hh }, { x: obj.x + hw, y: obj.y - hh },
                            { x: obj.x + hw, y: obj.y }, { x: obj.x + hw, y: obj.y + hh },
                            { x: obj.x, y: obj.y + hh }, { x: obj.x - hw, y: obj.y + hh }, { x: obj.x - hw, y: obj.y }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 画像オブジェクトの描画
                if (obj.type === 'image') {
                    drawImageObject(ctx, obj);
                    ctx.restore();

                    // 選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const bounds = getObjectBounds(obj);
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.w + 10, bounds.h + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: bounds.x, y: bounds.y }, { x: bounds.x + bounds.w / 2, y: bounds.y }, { x: bounds.x + bounds.w, y: bounds.y },
                            { x: bounds.x + bounds.w, y: bounds.y + bounds.h / 2 }, { x: bounds.x + bounds.w, y: bounds.y + bounds.h },
                            { x: bounds.x + bounds.w / 2, y: bounds.y + bounds.h }, { x: bounds.x, y: bounds.y + bounds.h }, { x: bounds.x, y: bounds.y + bounds.h / 2 }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 図形オブジェクトの描画
                if (['rect', 'roundRect', 'ellipse', 'triangle', 'line', 'chamferRect', 'arc'].includes(obj.type)) {
                    drawShape(ctx, obj);
                    ctx.restore();

                    // 選択枠
                    if (selectedObjIds.includes(obj.id)) {
                        const hw = obj.width / 2, hh = obj.height / 2;
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(obj.x - hw - 5, obj.y - hh - 5, obj.width + 10, obj.height + 10);
                        ctx.setLineDash([]);
                        const handles = [
                            { x: obj.x - hw, y: obj.y - hh }, { x: obj.x, y: obj.y - hh }, { x: obj.x + hw, y: obj.y - hh },
                            { x: obj.x + hw, y: obj.y }, { x: obj.x + hw, y: obj.y + hh },
                            { x: obj.x, y: obj.y + hh }, { x: obj.x - hw, y: obj.y + hh }, { x: obj.x - hw, y: obj.y }
                        ];
                        ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 1;
                        handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                    }
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // パス上文字オブジェクトの描画
                if (obj.type === 'pathText' && obj.path && obj.chars) {
                    // Convert relative path points to absolute
                    const absPath = obj.path.map(p => ({ x: p.x + obj.x, y: p.y + obj.y }));
                    const pathLen = getPathLength(absPath);

                    // Draw path line (faded)
                    if (selectedObjIds.includes(obj.id)) {
                        ctx.save();
                        ctx.strokeStyle = 'rgba(0, 120, 212, 0.3)';
                        ctx.lineWidth = 2;
                        ctx.setLineDash([5, 5]);
                        ctx.beginPath();
                        ctx.moveTo(absPath[0].x, absPath[0].y);
                        for (let i = 1; i < absPath.length; i++) {
                            ctx.lineTo(absPath[i].x, absPath[i].y);
                        }
                        ctx.stroke();
                        ctx.setLineDash([]);
                        ctx.restore();
                    }

                    // Calculate total text length along path
                    let totalTextLen = 0;
                    if (obj.vertical) {
                        // 縦書き: 文字の高さ（フォントサイズ）で計算
                        obj.chars.forEach(c => { totalTextLen += c.fontSize * 1.1; });
                    } else {
                        // 横書き: 文字の幅で計算
                        obj.chars.forEach(c => { totalTextLen += getCharWidth(c); });
                    }

                    // Start position along path (center text by default)
                    let dist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);

                    // Draw each character along path
                    obj.chars.forEach(c => {
                        let charLen;
                        if (obj.vertical) {
                            charLen = c.fontSize * 1.1;
                        } else {
                            charLen = getCharWidth(c);
                        }
                        const pos = getPointAtDistance(absPath, dist + charLen / 2);

                        const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                        const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;

                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';
                        ctx.textAlign = 'center';
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;

                        ctx.translate(pos.x, pos.y);

                        if (obj.vertical) {
                            // 縦書き: パスに沿って文字を直立させ、90度回転
                            ctx.rotate(pos.angle + Math.PI / 2);
                        } else {
                            // 横書き: パスの方向に沿って回転
                            ctx.rotate(pos.angle);
                        }

                        // Strokes
                        const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                        strokes.slice().reverse().forEach(st => {
                            if (!st.enabled) return;
                            ctx.save();
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                            ctx.strokeStyle = st.color;
                            ctx.lineWidth = st.width * 2;
                            ctx.lineJoin = st.join || 'round';
                            ctx.strokeText(dc, 0, 0);
                            ctx.restore();
                        });

                        // Fill
                        if (c.fillType !== 'none') {
                            ctx.fillStyle = c.color;
                            ctx.fillText(dc, 0, 0);
                        }

                        ctx.restore();
                        dist += charLen;
                    });

                    // Selection highlight for pathText
                    if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                        const s = Math.min(selectedCharStart, selectedCharEnd);
                        const en = Math.max(selectedCharStart, selectedCharEnd);
                        let hlDist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);

                        for (let i = 0; i < obj.chars.length; i++) {
                            const charLen = obj.vertical ? obj.chars[i].fontSize * 1.1 : getCharWidth(obj.chars[i]);
                            if (i >= s && i < en) {
                                const pos = getPointAtDistance(absPath, hlDist + charLen / 2);
                                ctx.save();
                                ctx.fillStyle = 'rgba(0,120,212,0.3)';
                                ctx.beginPath();
                                ctx.arc(pos.x, pos.y, obj.chars[i].fontSize / 2, 0, Math.PI * 2);
                                ctx.fill();
                                ctx.restore();
                            }
                            hlDist += charLen;
                        }
                    }

                    // Cursor for pathText
                    if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                        let cDist = (pathLen - totalTextLen) / 2 + (obj.pathOffset || 0);
                        for (let i = 0; i < cursorPos && i < obj.chars.length; i++) {
                            cDist += obj.vertical ? obj.chars[i].fontSize * 1.1 : getCharWidth(obj.chars[i]);
                        }
                        const cPos = getPointAtDistance(absPath, cDist);
                        const maxFs = Math.max(...obj.chars.map(c => c.fontSize), 72);

                        ctx.save();
                        ctx.strokeStyle = '#fff';
                        ctx.lineWidth = 2;
                        ctx.translate(cPos.x, cPos.y);
                        ctx.rotate(cPos.angle + (obj.vertical ? Math.PI / 2 : 0));
                        ctx.beginPath();
                        ctx.moveTo(0, -maxFs / 2);
                        ctx.lineTo(0, maxFs / 2);
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Selection box
                    if (obj.id === selectedObjId && obj.id !== editingObjId) {
                        const xs = absPath.map(p => p.x), ys = absPath.map(p => p.y);
                        const minX = Math.min(...xs), maxX = Math.max(...xs);
                        const minY = Math.min(...ys), maxY = Math.max(...ys);
                        const maxFs = Math.max(...obj.chars.map(c => c.fontSize));
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(minX - maxFs/2 - 5, minY - maxFs/2 - 5, maxX - minX + maxFs + 10, maxY - minY + maxFs + 10);
                        ctx.setLineDash([]);
                    }

                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // ペンパスオブジェクトの描画
                if (obj.type === 'penPath' && obj.path) {
                    const absPath = obj.path.map(p => ({
                        x: p.x + obj.x,
                        y: p.y + obj.y,
                        cp1: p.cp1 ? { x: p.cp1.x + obj.x, y: p.cp1.y + obj.y } : null,
                        cp2: p.cp2 ? { x: p.cp2.x + obj.x, y: p.cp2.y + obj.y } : null
                    }));

                    ctx.beginPath();
                    ctx.moveTo(absPath[0].x, absPath[0].y);
                    for (let i = 1; i < absPath.length; i++) {
                        const prev = absPath[i - 1];
                        const curr = absPath[i];
                        // ベジェ曲線または直線を描画
                        if (prev.cp2 || curr.cp1) {
                            const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                            const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                            ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                        } else {
                            ctx.lineTo(curr.x, curr.y);
                        }
                    }
                    if (obj.closed) ctx.closePath();

                    // Fill
                    if (obj.fillType !== 'none') {
                        ctx.globalAlpha = (obj.opacity || 100) / 100 * (obj.fillOpacity || 100) / 100;
                        ctx.fillStyle = obj.fill || '#ffffff';
                        ctx.fill();
                    }

                    // Stroke
                    ctx.globalAlpha = (obj.opacity || 100) / 100 * (obj.strokeOpacity || 100) / 100;
                    ctx.strokeStyle = obj.stroke || '#ffffff';
                    ctx.lineWidth = obj.strokeWidth || 3;
                    ctx.lineCap = 'round';
                    ctx.lineJoin = 'round';
                    ctx.stroke();

                    // Selection box and control points
                    if (selectedObjIds.includes(obj.id)) {
                        const bounds = getObjectBounds(obj);
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(bounds.x - 5, bounds.y - 5, bounds.w + 10, bounds.h + 10);
                        ctx.setLineDash([]);

                        // Draw control point handles for editing
                        ctx.globalAlpha = 1;
                        absPath.forEach((p, i) => {
                            // Draw anchor point
                            ctx.fillStyle = '#0078d4';
                            ctx.beginPath();
                            ctx.rect(p.x - 4, p.y - 4, 8, 8);
                            ctx.fill();

                            // Draw control point handles
                            if (p.cp1) {
                                ctx.strokeStyle = '#ff6600';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p.cp1.x, p.cp1.y);
                                ctx.stroke();
                                ctx.fillStyle = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(p.cp1.x, p.cp1.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                            if (p.cp2) {
                                ctx.strokeStyle = '#ff6600';
                                ctx.lineWidth = 1;
                                ctx.beginPath();
                                ctx.moveTo(p.x, p.y);
                                ctx.lineTo(p.cp2.x, p.cp2.y);
                                ctx.stroke();
                                ctx.fillStyle = '#ff6600';
                                ctx.beginPath();
                                ctx.arc(p.cp2.x, p.cp2.y, 3, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        });
                    }

                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // テキストオブジェクトの描画
                if (!obj.chars) {
                    ctx.restore();
                    // アニメーション位置を復元
                    obj.x = origX;
                    obj.y = origY;
                    return;
                }

                // 縦書きテキストの場合
                if (obj.vertical) {
                    const lines = getLines(obj);
                    const colWidth = getVerticalLineWidth(obj) * (obj.lineHeight || 1.2);
                    const totalWidth = lines.length * colWidth;

                    // 開始X位置（右から左へ描画）
                    let startX = obj.x;
                    if (obj.textAlign === 'center') startX = obj.x + totalWidth / 2 - colWidth / 2;
                    else if (obj.textAlign === 'left') startX = obj.x + totalWidth - colWidth;

                    // Get bounds for balloon and name tag
                    const bounds = getObjectBounds(obj);
                    drawBalloon(ctx, obj, bounds);

                    let ci = 0;
                    const maxVisibleChars = obj._visibleChars !== undefined ? obj._visibleChars : Infinity;
                    let totalCharIndex = 0;
                    for (let li = 0; li < lines.length; li++) {
                        const line = lines[li];
                        const colX = startX - li * colWidth;
                        const lineH = getVerticalLineHeight(line);

                        // 開始Y位置（縦揃え）
                        let startY = obj.y;
                        if (obj.verticalAlign === 'top') startY = obj.y;
                        else if (obj.verticalAlign === 'bottom') startY = obj.y - lineH;
                        else startY = obj.y - lineH / 2;

                        // Selection highlight for vertical text
                        if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                            const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                            let hlY = startY, hlSY = null, hlH = 0;
                            for (let i = 0; i < line.length; i++) {
                                const gi = ci + i, h = getCharHeight(line[i]);
                                if (gi >= s && gi < en) { if (hlSY === null) hlSY = hlY; hlH += h; }
                                hlY += h;
                            }
                            if (hlSY !== null && hlH > 0) {
                                ctx.fillStyle = 'rgba(0,120,212,0.3)';
                                ctx.fillRect(colX - colWidth / 2, hlSY, colWidth, hlH);
                            }
                        }

                        // Draw characters vertically
                        let py = startY;
                        line.forEach(c => {
                            // タイプライター効果: visibleCharsを超えた文字はスキップ
                            if (totalCharIndex >= maxVisibleChars) {
                                py += getCharHeight(c);
                                totalCharIndex++;
                                return;
                            }
                            const charIdx = totalCharIndex;
                            totalCharIndex++;

                            // 文字アニメーションを取得
                            const charAnim = obj._charAnimations ? obj._charAnimations[charIdx] : null;
                            if (charAnim && charAnim.opacity === 0) {
                                py += getCharHeight(c);
                                return;
                            }

                            const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;
                            const fs = c.smallCaps && /[a-z]/.test(c.char) ? c.fontSize * (c.smallCapsSize || 70) / 100 : c.fontSize;
                            ctx.save();
                            const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                            ctx.textBaseline = 'top';
                            ctx.textAlign = 'center';

                            // 文字アニメーションの不透明度を適用
                            let charOpacity = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100;
                            if (charAnim) charOpacity *= charAnim.opacity;
                            ctx.globalAlpha = charOpacity;

                            const bw = ctx.measureText(dc).width;
                            const sx = (c.scaleX || 100) / 100;
                            const cx = colX - (c.baselineShift || 0);

                            // 文字アニメーションのオフセットを適用
                            let animOffsetX = charAnim ? (charAnim.offsetX || 0) : 0;
                            let animOffsetY = charAnim ? (charAnim.offsetY || 0) : 0;

                            ctx.translate(cx + animOffsetX, py + animOffsetY);

                            // 文字アニメーションの回転とスケールを適用
                            if (charAnim) {
                                if (charAnim.rotation) ctx.rotate(charAnim.rotation * Math.PI / 180);
                                if (charAnim.scale && charAnim.scale !== 1) ctx.scale(charAnim.scale, charAnim.scale);
                            }

                            if (c.slant) ctx.transform(1, Math.tan(c.slant * Math.PI / 180), 0, 1, 0, 0);

                            // Shadow
                            if (c.shadowEnabled) {
                                const sa = (c.shadowAngle || 45) * Math.PI / 180;
                                const sd = c.shadowDistance || 5;
                                const sox = Math.cos(sa) * sd, soy = Math.sin(sa) * sd;
                                ctx.save();
                                ctx.scale(1, sx);
                                ctx.translate(sox, soy / sx);
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (c.shadowOpacity || 50) / 100;
                                ctx.shadowColor = c.shadowColor || '#000';
                                ctx.shadowBlur = c.shadowBlur || 5;
                                ctx.fillStyle = c.shadowColor || '#000';
                                ctx.fillText(dc, 0, 0);
                                ctx.restore();
                            }

                            ctx.scale(1, sx);

                            // Strokes
                            const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                            strokes.slice().reverse().forEach(st => {
                                if (!st.enabled) return;
                                ctx.save();
                                ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;
                                ctx.strokeStyle = st.color;
                                ctx.lineWidth = st.width * 2;
                                ctx.lineJoin = st.join || 'round';
                                ctx.strokeText(dc, 0, 0);
                                ctx.restore();
                            });

                            // Fill
                            if (c.fillType !== 'none') {
                                if (c.fillType === 'linear' || c.fillType === 'radial') {
                                    const gh = fs, gw = bw;
                                    let grad;
                                    if (c.fillType === 'linear') {
                                        const a = (c.gradientAngle || 0) * Math.PI / 180;
                                        const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                        grad = ctx.createLinearGradient(-dx, gh / 2 - dy, dx, gh / 2 + dy);
                                    } else {
                                        grad = ctx.createRadialGradient(0, gh / 2, 0, 0, gh / 2, Math.max(gw, gh) / 2);
                                    }
                                    if (c.gradientStops && c.gradientStops.length >= 2) {
                                        c.gradientStops.forEach((stop, i) => {
                                            const startPos = Math.max(0, stop.pos / 100);
                                            const endPos = Math.min(1, stop.endPos / 100);
                                            if (i === 0) grad.addColorStop(0, stop.color);
                                            else grad.addColorStop(startPos + 0.001, stop.color);
                                            if (i === c.gradientStops.length - 1) grad.addColorStop(1, stop.color);
                                            else grad.addColorStop(endPos - 0.001, stop.color);
                                        });
                                    } else {
                                        grad.addColorStop(0, c.color);
                                        grad.addColorStop(1, c.color2 || '#888');
                                    }
                                    ctx.fillStyle = grad;
                                } else {
                                    ctx.fillStyle = c.color;
                                }
                                ctx.fillText(dc, 0, 0);
                            }

                            ctx.restore();
                            py += getCharHeight(c);
                        });
                        ci += line.length + 1;
                    }

                    // Cursor for vertical text
                    if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                        let cCol = 0, cIdx = 0, count = 0;
                        for (let li = 0; li < lines.length; li++) {
                            if (cursorPos <= count + lines[li].length) { cCol = li; cIdx = cursorPos - count; break; }
                            count += lines[li].length + 1;
                        }
                        const line = lines[cCol] || [];
                        const colX = startX - cCol * colWidth;
                        const lineH = getVerticalLineHeight(line);

                        let cStartY = obj.y;
                        if (obj.verticalAlign === 'top') cStartY = obj.y;
                        else if (obj.verticalAlign === 'bottom') cStartY = obj.y - lineH;
                        else cStartY = obj.y - lineH / 2;

                        let cY = cStartY;
                        for (let i = 0; i < cIdx; i++) cY += getCharHeight(line[i]);

                        ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(colX - colWidth / 2, cY);
                        ctx.lineTo(colX + colWidth / 2, cY);
                        ctx.stroke();
                    }

                    // Selection box for vertical text
                    if (obj.id === selectedObjId && obj.id !== editingObjId) {
                        const b = bounds;
                        ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                        ctx.strokeRect(b.x - 5, b.y - 5, b.w + 10, b.h + 10);
                        ctx.setLineDash([]);
                    }

                    drawNameTag(ctx, obj, bounds);
                    ctx.restore();
                    return;
                }

                // 横書きテキストの描画
                const lines = getLines(obj), blh = getLineHeight(obj), lh = blh * (obj.lineHeight || 1.2), th = lines.length * lh;
                let startY = obj.y;
                if (obj.verticalAlign === 'top') startY = obj.y;
                else if (obj.verticalAlign === 'bottom') startY = obj.y - th + lh;
                else startY = obj.y - th / 2 + lh / 2;

                // Get bounds for balloon and name tag
                const bounds = getObjectBounds(obj);

                // Draw balloon (behind text)
                drawBalloon(ctx, obj, bounds);

                let ci = 0;
                const maxVisibleChars = obj._visibleChars !== undefined ? obj._visibleChars : Infinity;
                let totalCharIndex = 0;
                for (let li = 0; li < lines.length; li++) {
                    const line = lines[li], lineY = startY + li * lh, lw = getLineWidth(line);
                    let lx = obj.x;
                    if (obj.textAlign === 'center') lx = obj.x - lw / 2;
                    else if (obj.textAlign === 'right') lx = obj.x - lw;

                    // Selection highlight
                    if (obj.id === editingObjId && selectedCharStart !== -1 && selectedCharStart !== selectedCharEnd) {
                        const s = Math.min(selectedCharStart, selectedCharEnd), en = Math.max(selectedCharStart, selectedCharEnd);
                        let hlX = lx, hlSX = null, hlW = 0;
                        for (let i = 0; i < line.length; i++) {
                            const gi = ci + i, w = getCharWidth(line[i]);
                            if (gi >= s && gi < en) { if (hlSX === null) hlSX = hlX; hlW += w; }
                            hlX += w;
                        }
                        if (hlSX !== null && hlW > 0) { ctx.fillStyle = 'rgba(0,120,212,0.3)'; ctx.fillRect(hlSX, lineY - lh / 2, hlW, lh); }
                    }

                    // Draw characters
                    let px = lx;
                    line.forEach(c => {
                        // タイプライター効果: visibleCharsを超えた文字はスキップ
                        if (totalCharIndex >= maxVisibleChars) {
                            px += getCharWidth(c);
                            totalCharIndex++;
                            return;
                        }
                        const charIdx = totalCharIndex;
                        totalCharIndex++;

                        // 文字アニメーションを取得
                        const charAnim = obj._charAnimations ? obj._charAnimations[charIdx] : null;
                        if (charAnim && charAnim.opacity === 0) {
                            px += getCharWidth(c);
                            return;
                        }

                        const dc = c.smallCaps && /[a-z]/.test(c.char) ? c.char.toUpperCase() : c.char;

                        // キーフレームプロパティを適用
                        const kfp = obj._keyframeProps;
                        const fontSize = kfp ? kfp.fontSize : c.fontSize;
                        const charColor = kfp ? kfp.color : c.color;
                        const charColor2 = kfp ? kfp.color2 : c.color2;
                        const charOpacityBase = kfp ? kfp.opacity : (c.opacity || 100);
                        const charScaleX = kfp ? kfp.scaleX : (c.scaleX || 100);
                        const charSlant = kfp ? kfp.slant : (c.slant || 0);
                        const charSpacing = kfp ? kfp.letterSpacing : (c.letterSpacing || 0);

                        const fs = c.smallCaps && /[a-z]/.test(c.char) ? fontSize * (c.smallCapsSize || 70) / 100 : fontSize;
                        ctx.save();
                        const fontWeight = c.bold !== false ? 'bold' : 'normal';
            const fontStyle = c.italic ? 'italic' : 'normal';
            ctx.font = `${fontStyle} ${fontWeight} ${fs}px "${c.fontFamily}"`;
                        ctx.textBaseline = 'middle';

                        // 文字アニメーションの不透明度を適用
                        let charOpacity = (obj.opacity || 100) / 100 * charOpacityBase / 100;
                        if (charAnim) charOpacity *= charAnim.opacity;
                        ctx.globalAlpha = charOpacity;

                        const bw = ctx.measureText(dc).width, sx = charScaleX / 100, cy = lineY - (c.baselineShift || 0);

                        // 文字アニメーションのオフセットを適用
                        let animOffsetX = charAnim ? (charAnim.offsetX || 0) : 0;
                        let animOffsetY = charAnim ? (charAnim.offsetY || 0) : 0;

                        ctx.translate(px + animOffsetX, cy + animOffsetY);

                        // 文字アニメーションの回転とスケールを適用
                        if (charAnim) {
                            if (charAnim.rotation) ctx.rotate(charAnim.rotation * Math.PI / 180);
                            if (charAnim.scale && charAnim.scale !== 1) ctx.scale(charAnim.scale, charAnim.scale);
                        }

                        if (charSlant) ctx.transform(1, 0, Math.tan(charSlant * Math.PI / 180), 1, 0, 0);

                        // カーソル追従: カーソル描画
                        if (charAnim && charAnim.showCursor) {
                            ctx.save();
                            ctx.fillStyle = '#fff';
                            ctx.fillRect(-2, -fs/2, bw + 4, fs);
                            ctx.restore();
                        }

                        // Shadow (draw before scale to avoid offset distortion)
                        if (c.shadowEnabled) {
                            const sa = (c.shadowAngle || 45) * Math.PI / 180;
                            const sd = c.shadowDistance || 5;
                            const sox = Math.cos(sa) * sd, soy = Math.sin(sa) * sd;
                            ctx.save();
                            ctx.scale(sx, 1);
                            ctx.translate(sox / sx, soy); // Adjust for scale
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (c.shadowOpacity || 50) / 100;

                            // Apply blur effect
                            ctx.shadowColor = c.shadowColor || '#000';
                            ctx.shadowBlur = c.shadowBlur || 5;
                            ctx.shadowOffsetX = 0;
                            ctx.shadowOffsetY = 0;

                            // Shadow size (expansion) using stroke
                            const shadowSize = c.shadowSize || 0;
                            if (shadowSize > 0) {
                                ctx.lineWidth = shadowSize * 2;
                                ctx.lineJoin = 'round';
                                ctx.strokeStyle = c.shadowColor || '#000';
                                ctx.strokeText(dc, 0, 0);
                            }

                            ctx.fillStyle = c.shadowColor || '#000';
                            ctx.fillText(dc, 0, 0);
                            ctx.restore();
                        }

                        ctx.scale(sx, 1);

                        // Strokes
                        const strokes = c.strokes || [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100, join: 'round' }];
                        strokes.slice().reverse().forEach(st => {
                            if (!st.enabled) return;
                            ctx.save();
                            ctx.globalAlpha = (obj.opacity || 100) / 100 * (c.opacity || 100) / 100 * (st.opacity || 100) / 100;

                            // ストロークグラデーション対応
                            if (st.gradientEnabled && st.gradientStops && st.gradientStops.length >= 2) {
                                const gw = bw, gh = fs;
                                const centerX = gw / 2;
                                let grad;
                                if (st.gradientType === 'radial') {
                                    grad = ctx.createRadialGradient(centerX, 0, 0, centerX, 0, Math.max(gw, gh) / 2);
                                } else {
                                    const a = (st.gradientAngle || 90) * Math.PI / 180;
                                    const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                    grad = ctx.createLinearGradient(centerX - dx, -dy, centerX + dx, dy);
                                }
                                st.gradientStops.forEach((stop, i) => {
                                    const pos = Math.max(0, Math.min(1, stop.pos / 100));
                                    grad.addColorStop(pos, stop.color);
                                });
                                ctx.strokeStyle = grad;
                            } else {
                                ctx.strokeStyle = st.color;
                            }

                            ctx.lineWidth = st.width * 2;
                            ctx.lineJoin = st.join || 'round';
                            if (st.type === 'depth') {
                                const depthAngle = (st.angle || 45) * Math.PI / 180;
                                const depthDx = Math.cos(depthAngle);
                                const depthDy = Math.sin(depthAngle);
                                for (let d = st.width; d > 0; d--) {
                                    if (!st.gradientEnabled) ctx.strokeStyle = st.color;
                                    ctx.lineWidth = 2;
                                    ctx.save();
                                    ctx.translate(d * depthDx, d * depthDy);
                                    ctx.strokeText(dc, 0, 0);
                                    ctx.restore();
                                }
                            } else if (st.type === 'drop') {
                                ctx.save();
                                ctx.translate(st.width, st.width);
                                ctx.fillStyle = st.gradientEnabled ? ctx.strokeStyle : st.color;
                                ctx.fillText(dc, 0, 0);
                                ctx.restore();
                            } else {
                                ctx.strokeText(dc, 0, 0);
                            }
                            ctx.restore();
                        });

                        // Fill
                        if (c.fillType !== 'none') {
                            if (c.fillType === 'linear' || c.fillType === 'radial') {
                                // Use character width in current coordinate system (after scale)
                                const gw = bw, gh = fs;
                                const centerX = gw / 2; // Character center X
                                let grad;
                                if (c.fillType === 'linear') {
                                    const a = (c.gradientAngle || 0) * Math.PI / 180;
                                    const dx = Math.cos(a) * gw / 2, dy = Math.sin(a) * gh / 2;
                                    // Center gradient at character center
                                    grad = ctx.createLinearGradient(centerX - dx, -dy, centerX + dx, dy);
                                } else {
                                    grad = ctx.createRadialGradient(centerX, 0, 0, centerX, 0, Math.max(gw, gh) / 2);
                                }
                            // Use multiple color stops based on ratio with blur support
                            if (c.gradientStops && c.gradientStops.length >= 2) {
                                const blur = (c.gradientBlur || 0) / 100; // 0-1 range

                                c.gradientStops.forEach((stop, i) => {
                                    const startPos = Math.max(0, Math.min(1, stop.pos / 100));
                                    const endPos = Math.max(0, Math.min(1, stop.endPos / 100));

                                    if (blur === 0) {
                                        // Sharp boundaries
                                        if (i === 0) {
                                            grad.addColorStop(0, stop.color);
                                        } else {
                                            grad.addColorStop(Math.min(1, startPos + 0.001), stop.color);
                                        }
                                        if (i === c.gradientStops.length - 1) {
                                            grad.addColorStop(1, stop.color);
                                        } else {
                                            grad.addColorStop(Math.max(0, endPos - 0.001), stop.color);
                                        }
                                    } else {
                                        // Smooth transitions with blur
                                        const blurAmount = blur * 0.5; // Max 50% of range for blur

                                        if (i === 0) {
                                            grad.addColorStop(0, stop.color);
                                            // Blend towards next color
                                            if (i < c.gradientStops.length - 1) {
                                                const blendEnd = Math.max(0, Math.min(1, endPos - blurAmount));
                                                if (blendEnd > 0) grad.addColorStop(blendEnd, stop.color);
                                            }
                                        } else if (i === c.gradientStops.length - 1) {
                                            // Blend from previous color
                                            const blendStart = Math.max(0, Math.min(1, startPos + blurAmount));
                                            if (blendStart < 1) grad.addColorStop(blendStart, stop.color);
                                            grad.addColorStop(1, stop.color);
                                        } else {
                                            // Middle colors - blend on both sides
                                            const blendStart = Math.max(0, Math.min(1, startPos + blurAmount));
                                            const blendEnd = Math.max(0, Math.min(1, endPos - blurAmount));
                                            if (blendStart < blendEnd) {
                                                grad.addColorStop(blendStart, stop.color);
                                                grad.addColorStop(blendEnd, stop.color);
                                            } else {
                                                // Range too small, just use midpoint
                                                const midPoint = Math.max(0, Math.min(1, (startPos + endPos) / 2));
                                                grad.addColorStop(midPoint, stop.color);
                                            }
                                        }
                                    }
                                });
                            } else {
                                grad.addColorStop(0, charColor);
                                grad.addColorStop(1, charColor2 || '#888');
                            }
                                ctx.fillStyle = grad;
                            } else {
                                ctx.fillStyle = charColor;
                            }
                            ctx.fillText(dc, 0, 0);
                        }

                        // Gloss - horizontal band overlay on text fill only (not strokes)
                        if (c.glossEnabled) {
                            const glossWidth = c.glossWidth || 10;
                            const glossBlur = c.glossBlur || 5;
                            const glossCol = c.glossColor || '#ffffff';
                            const glossOpacity = (c.glossOpacity || 50) / 100;

                            // Parse color
                            const gr = parseInt(glossCol.slice(1, 3), 16);
                            const gg = parseInt(glossCol.slice(3, 5), 16);
                            const gb = parseInt(glossCol.slice(5, 7), 16);

                            // Create temp canvas for gloss clipping to text fill only
                            const glossCanvas = document.createElement('canvas');
                            const margin = 10;
                            glossCanvas.width = bw + margin * 2;
                            glossCanvas.height = fs + margin * 2;
                            const glossCtx = glossCanvas.getContext('2d');

                            // Draw text fill as mask
                            glossCtx.font = ctx.font;
                            glossCtx.textBaseline = 'middle';
                            glossCtx.textAlign = 'left';
                            glossCtx.fillStyle = '#fff';
                            glossCtx.fillText(dc, margin, glossCanvas.height / 2);

                            // Apply gloss only inside text
                            glossCtx.globalCompositeOperation = 'source-in';

                            // Calculate band dimensions
                            const bandHeight = glossWidth;
                            const fadeHeight = glossBlur;
                            const totalHeight = bandHeight + fadeHeight * 2;
                            const glossY = glossCanvas.height / 2;

                            // Create vertical gradient for horizontal band
                            const glossGrad = glossCtx.createLinearGradient(0, glossY - totalHeight/2, 0, glossY + totalHeight/2);
                            glossGrad.addColorStop(0, `rgba(${gr},${gg},${gb},0)`);
                            if (fadeHeight > 0 && totalHeight > 0) {
                                const fadeRatio = Math.min(0.49, fadeHeight / totalHeight);
                                glossGrad.addColorStop(fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                                glossGrad.addColorStop(1 - fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                            } else {
                                glossGrad.addColorStop(0.01, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                                glossGrad.addColorStop(0.99, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                            }
                            glossGrad.addColorStop(1, `rgba(${gr},${gg},${gb},0)`);

                            glossCtx.fillStyle = glossGrad;
                            glossCtx.fillRect(0, glossY - totalHeight/2, glossCanvas.width, totalHeight);

                            // Draw gloss result on main canvas
                            ctx.drawImage(glossCanvas, -margin, -glossCanvas.height/2);
                        }

                        ctx.restore();
                        px += getCharWidth(c) + charSpacing;
                    });
                    ci += line.length + 1;
                }

                // Cursor
                if (obj.id === editingObjId && cursorVisible && selectedCharStart === -1) {
                    let cLine = 0, cIdx = 0, count = 0;
                    for (let li = 0; li < lines.length; li++) {
                        if (cursorPos <= count + lines[li].length) { cLine = li; cIdx = cursorPos - count; break; }
                        count += lines[li].length + 1;
                    }
                    const line = lines[cLine] || [], lineY = startY + cLine * lh, lw = getLineWidth(line);
                    let clx = obj.x;
                    if (obj.textAlign === 'center') clx = obj.x - lw / 2;
                    else if (obj.textAlign === 'right') clx = obj.x - lw;
                    let cX = clx;
                    for (let i = 0; i < cIdx; i++) cX += getCharWidth(line[i]);
                    ctx.strokeStyle = '#fff'; ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(cX, lineY - lh / 2); ctx.lineTo(cX, lineY + lh / 2); ctx.stroke();
                }

                ctx.restore();

                // Draw name tag (after text)
                drawNameTag(ctx, obj, bounds);

                // Selection box and handles
                if (obj.id === selectedObjId && obj.id !== editingObjId) {
                    const b = getObjectBounds(obj);
                    ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 2; ctx.setLineDash([5, 3]);
                    ctx.strokeRect(b.x - 5, b.y - 5, b.w + 10, b.h + 10);
                    ctx.setLineDash([]);
                    const handles = [
                        { x: b.x, y: b.y }, { x: b.x + b.w / 2, y: b.y }, { x: b.x + b.w, y: b.y },
                        { x: b.x + b.w, y: b.y + b.h / 2 }, { x: b.x + b.w, y: b.y + b.h },
                        { x: b.x + b.w / 2, y: b.y + b.h }, { x: b.x, y: b.y + b.h }, { x: b.x, y: b.y + b.h / 2 }
                    ];
                    ctx.fillStyle = '#fff'; ctx.strokeStyle = '#0078d4'; ctx.lineWidth = 1;
                    handles.forEach(h => { ctx.fillRect(h.x - 4, h.y - 4, 8, 8); ctx.strokeRect(h.x - 4, h.y - 4, 8, 8); });
                }

                // アニメーション位置を復元
                obj.x = origX;
                obj.y = origY;
            });

            // 図形描画プレビュー
            if (tempShape && isDrawingShape) {
                ctx.save();
                ctx.strokeStyle = '#0078d4';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                const x = Math.min(tempShape.x1, tempShape.x2);
                const y = Math.min(tempShape.y1, tempShape.y2);
                const w = Math.abs(tempShape.x2 - tempShape.x1);
                const h = Math.abs(tempShape.y2 - tempShape.y1);

                if (tempShape.type === 'rect') {
                    ctx.strokeRect(x, y, w, h);
                } else if (tempShape.type === 'roundRect') {
                    const r = Math.min(20, w / 2, h / 2);
                    drawRoundedRect(ctx, x, y, w, h, r);
                    ctx.stroke();
                } else if (tempShape.type === 'ellipse') {
                    ctx.beginPath();
                    ctx.ellipse(x + w / 2, y + h / 2, w / 2, h / 2, 0, 0, Math.PI * 2);
                    ctx.stroke();
                } else if (tempShape.type === 'triangle') {
                    ctx.beginPath();
                    ctx.moveTo(x + w / 2, y);
                    ctx.lineTo(x + w, y + h);
                    ctx.lineTo(x, y + h);
                    ctx.closePath();
                    ctx.stroke();
                } else if (tempShape.type === 'line') {
                    ctx.beginPath();
                    ctx.moveTo(tempShape.x1, tempShape.y1);
                    ctx.lineTo(tempShape.x2, tempShape.y2);
                    ctx.stroke();
                } else if (tempShape.type === 'chamferRect') {
                    const c = Math.min(10, w / 4, h / 4);
                    ctx.beginPath();
                    ctx.moveTo(x + c, y);
                    ctx.lineTo(x + w - c, y);
                    ctx.lineTo(x + w, y + c);
                    ctx.lineTo(x + w, y + h - c);
                    ctx.lineTo(x + w - c, y + h);
                    ctx.lineTo(x + c, y + h);
                    ctx.lineTo(x, y + h - c);
                    ctx.lineTo(x, y + c);
                    ctx.closePath();
                    ctx.stroke();
                } else if (tempShape.type === 'arc') {
                    ctx.beginPath();
                    ctx.arc(x + w / 2, y + h, Math.min(w / 2, h), Math.PI, 0);
                    ctx.stroke();
                }
                ctx.restore();
            }

            // パス描画プレビュー
            if (isDrawingPath && pathPoints.length > 0) {
                ctx.save();
                ctx.strokeStyle = '#0078d4';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(pathPoints[0].x, pathPoints[0].y);
                for (let i = 1; i < pathPoints.length; i++) {
                    const prev = pathPoints[i - 1];
                    const curr = pathPoints[i];
                    // ベジェ曲線または直線
                    if (prev.cp2 || curr.cp1) {
                        const cp1 = prev.cp2 || { x: prev.x, y: prev.y };
                        const cp2 = curr.cp1 || { x: curr.x, y: curr.y };
                        ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, curr.x, curr.y);
                    } else {
                        ctx.lineTo(curr.x, curr.y);
                    }
                }
                ctx.stroke();
                ctx.setLineDash([]);

                // Draw anchor points
                ctx.fillStyle = '#0078d4';
                pathPoints.forEach(p => {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw control point handles for last point (during drag)
                if (currentTool === 'pen' && pathPoints.length > 0) {
                    const lastPoint = pathPoints[pathPoints.length - 1];
                    if (lastPoint.cp1 || lastPoint.cp2) {
                        ctx.strokeStyle = '#ff6600';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([]);

                        // Draw handle lines and control points
                        if (lastPoint.cp1) {
                            ctx.beginPath();
                            ctx.moveTo(lastPoint.x, lastPoint.y);
                            ctx.lineTo(lastPoint.cp1.x, lastPoint.cp1.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(lastPoint.cp1.x, lastPoint.cp1.y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#ff6600';
                            ctx.fill();
                        }
                        if (lastPoint.cp2) {
                            ctx.beginPath();
                            ctx.moveTo(lastPoint.x, lastPoint.y);
                            ctx.lineTo(lastPoint.cp2.x, lastPoint.cp2.y);
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.arc(lastPoint.cp2.x, lastPoint.cp2.y, 3, 0, Math.PI * 2);
                            ctx.fillStyle = '#ff6600';
                            ctx.fill();
                        }
                    }
                }
                ctx.restore();
            }

            // セーフマージン描画（最前面）
            drawSafeMargins(ctx);

            let statusMsg = `オブジェクト: ${textObjects.length}`;
            if (editingObjId) {
                statusMsg = '編集中 (Esc終了)';
            } else if (isDrawingPath) {
                statusMsg = `パス描画中 (${pathPoints.length}点) - ダブルクリックで完成`;
            } else if (selectedObjIds.length > 1) {
                statusMsg = `${selectedObjIds.length}個選択中 (Ctrl+G: グループ化)`;
            }
            document.getElementById('statusText').textContent = statusMsg;
        }

        function changeResolution() {
            const [w, h] = document.getElementById('resolution').value.split('x').map(Number);
            canvas.width = w; canvas.height = h;
            document.getElementById('resolution-display').textContent = `${w}×${h}`;
            render();
        }

        // 画像関連の関数
        let pickingColor = false;  // スポイトモード

        function insertImage() {
            document.getElementById('imageInput').click();
        }

        function handleImageLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    saveState();
                    const imageObj = {
                        id: Date.now(),
                        type: 'image',
                        name: file.name.substring(0, 20),
                        x: canvas.width / 2,
                        y: canvas.height / 2,
                        width: img.width,
                        height: img.height,
                        originalWidth: img.width,
                        originalHeight: img.height,
                        rotation: 0,
                        opacity: 100,
                        flipH: false,
                        flipV: false,
                        crop: { left: 0, top: 0, right: 0, bottom: 0 },
                        transparent: { enabled: false, color: '#00ff00', tolerance: 30 },
                        stroke: { color: '#000000', width: 0 },
                        imageData: event.target.result  // Base64データ
                    };
                    // キャンバスに収まるようにリサイズ
                    const maxW = canvas.width * 0.8;
                    const maxH = canvas.height * 0.8;
                    if (imageObj.width > maxW || imageObj.height > maxH) {
                        const scale = Math.min(maxW / imageObj.width, maxH / imageObj.height);
                        imageObj.width = Math.round(imageObj.width * scale);
                        imageObj.height = Math.round(imageObj.height * scale);
                    }
                    textObjects.push(imageObj);
                    selectObject(imageObj.id);
                    updateLayerList();
                    render();
                };
                img.src = event.target.result;
            };
            reader.readAsDataURL(file);
            e.target.value = '';
        }

        function updateImageSize() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            const newW = parseInt(document.getElementById('imageWidth').value) || obj.width;
            const newH = parseInt(document.getElementById('imageHeight').value) || obj.height;
            const lockAspect = document.getElementById('imageLockAspect').checked;

            if (lockAspect) {
                if (newW !== obj.width) {
                    const scale = newW / obj.width;
                    obj.width = newW;
                    obj.height = Math.round(obj.height * scale);
                    document.getElementById('imageHeight').value = obj.height;
                } else if (newH !== obj.height) {
                    const scale = newH / obj.height;
                    obj.height = newH;
                    obj.width = Math.round(obj.width * scale);
                    document.getElementById('imageWidth').value = obj.width;
                }
            } else {
                obj.width = newW;
                obj.height = newH;
            }
            render();
        }

        function flipImage(direction) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;
            saveState();
            if (direction === 'h') obj.flipH = !obj.flipH;
            else obj.flipV = !obj.flipV;
            render();
        }

        function updateImageCrop() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.crop = {
                left: parseInt(document.getElementById('imageCropLeft').value) || 0,
                top: parseInt(document.getElementById('imageCropTop').value) || 0,
                right: parseInt(document.getElementById('imageCropRight').value) || 0,
                bottom: parseInt(document.getElementById('imageCropBottom').value) || 0
            };
            render();
        }

        function updateImageTransparency() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.transparent = {
                enabled: document.getElementById('imageTransparentEnabled').checked,
                color: document.getElementById('imageTransparentColor').value,
                tolerance: parseInt(document.getElementById('imageTransparentTolerance').value) || 30
            };
            render();
        }

        function pickTransparentColor() {
            pickingColor = true;
            canvas.style.cursor = 'crosshair';
        }

        function updateImageStroke() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'image') return;

            obj.stroke = {
                color: document.getElementById('imageStrokeColor').value,
                width: parseInt(document.getElementById('imageStrokeWidth').value) || 0
            };
            render();
        }

        function loadImageUI(obj) {
            const panel = document.getElementById('imageSettings');
            if (!obj || obj.type !== 'image') {
                panel.classList.add('hidden');
                panel.previousElementSibling.classList.add('collapsed');
                return;
            }

            panel.classList.remove('hidden');
            panel.previousElementSibling.classList.remove('collapsed');

            document.getElementById('imageWidth').value = obj.width;
            document.getElementById('imageHeight').value = obj.height;
            document.getElementById('imageCropLeft').value = obj.crop?.left || 0;
            document.getElementById('imageCropTop').value = obj.crop?.top || 0;
            document.getElementById('imageCropRight').value = obj.crop?.right || 0;
            document.getElementById('imageCropBottom').value = obj.crop?.bottom || 0;
            document.getElementById('imageTransparentEnabled').checked = obj.transparent?.enabled || false;
            document.getElementById('imageTransparentColor').value = obj.transparent?.color || '#00ff00';
            document.getElementById('imageTransparentTolerance').value = obj.transparent?.tolerance || 30;
            document.getElementById('imageStrokeColor').value = obj.stroke?.color || '#000000';
            document.getElementById('imageStrokeWidth').value = obj.stroke?.width || 0;
        }

        // 画像の描画関数
        const imageCache = {};  // 画像キャッシュ

        function drawImageObject(ctx, obj) {
            if (!obj.imageData) return;

            // 画像をキャッシュから取得または作成
            let img = imageCache[obj.id];
            if (!img || img.src !== obj.imageData) {
                img = new Image();
                img.src = obj.imageData;
                imageCache[obj.id] = img;
            }

            if (!img.complete) return;

            const crop = obj.crop || { left: 0, top: 0, right: 0, bottom: 0 };
            const srcX = crop.left;
            const srcY = crop.top;
            const srcW = obj.originalWidth - crop.left - crop.right;
            const srcH = obj.originalHeight - crop.top - crop.bottom;

            if (srcW <= 0 || srcH <= 0) return;

            ctx.save();

            // 反転
            const scaleX = obj.flipH ? -1 : 1;
            const scaleY = obj.flipV ? -1 : 1;
            ctx.translate(obj.x, obj.y);
            ctx.scale(scaleX, scaleY);
            ctx.translate(-obj.x, -obj.y);

            const dstW = obj.width * (srcW / obj.originalWidth);
            const dstH = obj.height * (srcH / obj.originalHeight);
            const dstX = obj.x - dstW / 2;
            const dstY = obj.y - dstH / 2;

            // 色透過処理
            if (obj.transparent?.enabled) {
                // オフスクリーンキャンバスで処理
                const offCanvas = document.createElement('canvas');
                offCanvas.width = srcW;
                offCanvas.height = srcH;
                const offCtx = offCanvas.getContext('2d');
                offCtx.drawImage(img, srcX, srcY, srcW, srcH, 0, 0, srcW, srcH);

                const imageData = offCtx.getImageData(0, 0, srcW, srcH);
                const data = imageData.data;
                const targetColor = hexToRgb(obj.transparent.color);
                const tolerance = obj.transparent.tolerance;

                for (let i = 0; i < data.length; i += 4) {
                    const r = data[i], g = data[i + 1], b = data[i + 2];
                    const diff = Math.abs(r - targetColor.r) + Math.abs(g - targetColor.g) + Math.abs(b - targetColor.b);
                    if (diff <= tolerance * 3) {
                        data[i + 3] = 0;  // 透明に
                    }
                }
                offCtx.putImageData(imageData, 0, 0);
                ctx.drawImage(offCanvas, dstX, dstY, dstW, dstH);
            } else {
                ctx.drawImage(img, srcX, srcY, srcW, srcH, dstX, dstY, dstW, dstH);
            }

            // ストローク
            if (obj.stroke?.width > 0) {
                ctx.strokeStyle = obj.stroke.color;
                ctx.lineWidth = obj.stroke.width;
                ctx.strokeRect(dstX, dstY, dstW, dstH);
            }

            ctx.restore();
        }

        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        function exportPNG() {
            exitEditMode(); selectedObjId = null; selectedObjIds = [];
            // 一時的にセーフマージンを非表示にしてレンダリング
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;

            // 背景透過設定
            exportingTransparent = document.getElementById('exportTransparent').checked;
            render();

            const link = document.createElement('a');
            link.download = `telop_${Date.now()}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();

            // 元に戻す
            exportingTransparent = false;
            safeMarginCheckbox.checked = wasEnabled;
            render();
        }

        // ========== アニメーション機能 ==========

        function updateAnimation() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;

            obj.animation = {
                type: document.getElementById('animType').value,
                duration: parseFloat(document.getElementById('animDuration').value) || 2,
                delay: parseFloat(document.getElementById('animDelay').value) || 0,
                speed: parseFloat(document.getElementById('animSpeed').value) || 100,
                easing: document.getElementById('animEasing').value,
                loop: document.getElementById('animLoop').checked
            };
            render();
        }

        function loadAnimationUI(obj) {
            const panel = document.getElementById('animationSettings');
            if (!obj || !obj.animation) {
                document.getElementById('animType').value = 'none';
                document.getElementById('animDuration').value = 2;
                document.getElementById('animDelay').value = 0;
                document.getElementById('animSpeed').value = 100;
                document.getElementById('animEasing').value = 'linear';
                document.getElementById('animLoop').checked = false;
                return;
            }

            document.getElementById('animType').value = obj.animation.type || 'none';
            document.getElementById('animDuration').value = obj.animation.duration || 2;
            document.getElementById('animDelay').value = obj.animation.delay || 0;
            document.getElementById('animSpeed').value = obj.animation.speed || 100;
            document.getElementById('animEasing').value = obj.animation.easing || 'linear';
            document.getElementById('animLoop').checked = obj.animation.loop || false;
            updateKeyframeList();
        }

        // キーフレーム関連関数
        function addKeyframe() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj) return;

            if (!obj.keyframes) obj.keyframes = [];

            const newTime = obj.keyframes.length > 0 ?
                Math.max(...obj.keyframes.map(k => k.time)) + 1 : 0;

            obj.keyframes.push({
                time: newTime,
                props: {
                    fontSize: 60,
                    color: '#ffffff',
                    opacity: 100,
                    scaleX: 100,
                    letterSpacing: 0,
                    slant: 0
                }
            });

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        function addKeyframeFromCurrent() {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.chars || obj.chars.length === 0) return;

            if (!obj.keyframes) obj.keyframes = [];

            // 現在の最初の文字のスタイルを取得
            const c = obj.chars[0];
            const newTime = obj.keyframes.length > 0 ?
                Math.max(...obj.keyframes.map(k => k.time)) + 1 : 0;

            obj.keyframes.push({
                time: newTime,
                props: {
                    fontSize: c.fontSize || 60,
                    color: c.color || '#ffffff',
                    color2: c.color2 || '#888888',
                    fillType: c.fillType || 'solid',
                    gradientAngle: c.gradientAngle || 0,
                    opacity: c.opacity || 100,
                    scaleX: c.scaleX || 100,
                    letterSpacing: c.letterSpacing || 0,
                    slant: c.slant || 0
                }
            });

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        function updateKeyframeList() {
            const list = document.getElementById('keyframeList');
            if (!selectedObjId) {
                list.innerHTML = '<div style="color:#888;font-size:11px;">オブジェクトを選択してください</div>';
                return;
            }

            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes || obj.keyframes.length === 0) {
                list.innerHTML = '<div style="color:#888;font-size:11px;">キーフレームなし</div>';
                return;
            }

            list.innerHTML = obj.keyframes.map((kf, i) => `
                <div style="border-bottom:1px solid #444;padding:5px 0;font-size:11px;">
                    <div style="display:flex;justify-content:space-between;align-items:center;">
                        <span><b>${kf.time}秒</b></span>
                        <div>
                            <button class="btn btn-small" onclick="editKeyframe(${i})" style="padding:2px 5px;font-size:10px;">編集</button>
                            <button class="btn btn-small btn-danger" onclick="deleteKeyframe(${i})" style="padding:2px 5px;font-size:10px;">×</button>
                        </div>
                    </div>
                    <div style="color:#aaa;font-size:10px;margin-top:3px;">
                        ${kf.props.fontSize}px / ${kf.props.opacity}% / ${kf.props.color}
                    </div>
                </div>
            `).join('');
        }

        function deleteKeyframe(index) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes) return;

            obj.keyframes.splice(index, 1);
            updateKeyframeList();
        }

        function editKeyframe(index) {
            if (!selectedObjId) return;
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || !obj.keyframes || !obj.keyframes[index]) return;

            const kf = obj.keyframes[index];
            const newTime = prompt('時間（秒）:', kf.time);
            if (newTime === null) return;
            kf.time = parseFloat(newTime) || 0;

            const newSize = prompt('フォントサイズ:', kf.props.fontSize);
            if (newSize !== null) kf.props.fontSize = parseInt(newSize) || 60;

            const newOpacity = prompt('不透明度 (0-100):', kf.props.opacity);
            if (newOpacity !== null) kf.props.opacity = parseInt(newOpacity) || 100;

            const newColor = prompt('色 (#xxxxxx):', kf.props.color);
            if (newColor !== null) kf.props.color = newColor || '#ffffff';

            const newScaleX = prompt('縦横比率 (%):', kf.props.scaleX);
            if (newScaleX !== null) kf.props.scaleX = parseInt(newScaleX) || 100;

            const newSpacing = prompt('カーニング:', kf.props.letterSpacing);
            if (newSpacing !== null) kf.props.letterSpacing = parseInt(newSpacing) || 0;

            const newSlant = prompt('斜め角度:', kf.props.slant);
            if (newSlant !== null) kf.props.slant = parseInt(newSlant) || 0;

            obj.keyframes.sort((a, b) => a.time - b.time);
            updateKeyframeList();
        }

        // キーフレーム補間
        function interpolateKeyframes(obj) {
            if (!obj.keyframes || obj.keyframes.length === 0) return null;

            const kfs = obj.keyframes;
            const t = animationTime;

            // 時間範囲外
            if (t <= kfs[0].time) return kfs[0].props;
            if (t >= kfs[kfs.length - 1].time) return kfs[kfs.length - 1].props;

            // 補間するキーフレームを探す
            let prev = kfs[0], next = kfs[1];
            for (let i = 0; i < kfs.length - 1; i++) {
                if (t >= kfs[i].time && t <= kfs[i + 1].time) {
                    prev = kfs[i];
                    next = kfs[i + 1];
                    break;
                }
            }

            // 補間率
            const duration = next.time - prev.time;
            const progress = duration > 0 ? (t - prev.time) / duration : 0;

            // 各プロパティを補間
            return {
                fontSize: lerp(prev.props.fontSize, next.props.fontSize, progress),
                color: lerpColor(prev.props.color, next.props.color, progress),
                color2: lerpColor(prev.props.color2 || prev.props.color, next.props.color2 || next.props.color, progress),
                fillType: progress < 0.5 ? prev.props.fillType : next.props.fillType,
                gradientAngle: lerp(prev.props.gradientAngle || 0, next.props.gradientAngle || 0, progress),
                opacity: lerp(prev.props.opacity, next.props.opacity, progress),
                scaleX: lerp(prev.props.scaleX, next.props.scaleX, progress),
                letterSpacing: lerp(prev.props.letterSpacing || 0, next.props.letterSpacing || 0, progress),
                slant: lerp(prev.props.slant || 0, next.props.slant || 0, progress)
            };
        }

        // 線形補間
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }

        // 色の補間
        function lerpColor(c1, c2, t) {
            if (!c1 || !c2) return c1 || c2 || '#ffffff';
            const r1 = parseInt(c1.slice(1, 3), 16);
            const g1 = parseInt(c1.slice(3, 5), 16);
            const b1 = parseInt(c1.slice(5, 7), 16);
            const r2 = parseInt(c2.slice(1, 3), 16);
            const g2 = parseInt(c2.slice(3, 5), 16);
            const b2 = parseInt(c2.slice(5, 7), 16);
            const r = Math.round(lerp(r1, r2, t));
            const g = Math.round(lerp(g1, g2, t));
            const b = Math.round(lerp(b1, b2, t));
            return '#' + [r, g, b].map(v => v.toString(16).padStart(2, '0')).join('');
        }

        function toggleAnimation() {
            if (isPlaying) {
                stopAnimation();
            } else {
                startAnimation();
            }
        }

        function startAnimation() {
            isPlaying = true;
            animationStartTime = performance.now() - animationTime * 1000;
            document.getElementById('playIcon').innerHTML = '<rect x="6" y="4" width="4" height="16" fill="currentColor"/><rect x="14" y="4" width="4" height="16" fill="currentColor"/>';
            animationLoop();
        }

        function stopAnimation() {
            isPlaying = false;
            if (animationFrame) cancelAnimationFrame(animationFrame);
            document.getElementById('playIcon').innerHTML = '<path d="M8 5v14l11-7z" fill="currentColor"/>';
        }

        function resetAnimation() {
            stopAnimation();
            animationTime = 0;
            document.getElementById('timeline').value = 0;
            render();
        }

        function seekAnimation(value) {
            animationTime = (value / 100) * totalDuration;
            if (isPlaying) {
                animationStartTime = performance.now() - animationTime * 1000;
            }
            render();
        }

        function animationLoop() {
            if (!isPlaying) return;

            const now = performance.now();
            animationTime = (now - animationStartTime) / 1000;

            // 最大時間を超えたらループまたは停止
            if (animationTime >= totalDuration) {
                const hasLoop = textObjects.some(obj => obj.animation?.loop);
                if (hasLoop) {
                    animationTime = 0;
                    animationStartTime = now;
                } else {
                    stopAnimation();
                    animationTime = totalDuration;
                }
            }

            // タイムラインスライダーを更新
            document.getElementById('timeline').value = (animationTime / totalDuration) * 100;

            render();
            animationFrame = requestAnimationFrame(animationLoop);
        }

        // イージング関数
        function easeValue(t, easing) {
            switch (easing) {
                case 'easeIn': return t * t;
                case 'easeOut': return t * (2 - t);
                case 'easeInOut': return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
                default: return t; // linear
            }
        }

        // アニメーション適用（renderの前に呼ばれる）
        function getAnimatedProperties(obj) {
            const charCount = obj.chars?.length || 0;
            if (!obj.animation || obj.animation.type === 'none') {
                return { opacity: obj.opacity || 100, x: obj.x, y: obj.y, visibleChars: charCount, charAnimations: null };
            }

            const anim = obj.animation;
            const delay = anim.delay || 0;
            const duration = anim.duration || 2;
            const speed = (anim.speed || 100) / 100;

            let t = (animationTime - delay) / duration;
            if (t < 0) t = 0;
            if (t > 1) t = anim.loop ? (t % 1) : 1;

            t = easeValue(t, anim.easing);

            let opacity = obj.opacity || 100;
            let x = obj.x;
            let y = obj.y;
            let visibleChars = charCount;
            let charAnimations = null;  // 各文字ごとのアニメーション

            switch (anim.type) {
                case 'fadeIn':
                    opacity = t * (obj.opacity || 100);
                    break;
                case 'fadeOut':
                    opacity = (1 - t) * (obj.opacity || 100);
                    break;
                case 'slideLeft':
                    x = obj.x - (1 - t) * canvas.width * 0.5;
                    break;
                case 'slideRight':
                    x = obj.x + (1 - t) * canvas.width * 0.5;
                    break;
                case 'slideUp':
                    y = obj.y - (1 - t) * canvas.height * 0.5;
                    break;
                case 'slideDown':
                    y = obj.y + (1 - t) * canvas.height * 0.5;
                    break;
                case 'typewriter':
                    if (obj.chars) {
                        visibleChars = Math.floor(t * charCount);
                    }
                    break;
                case 'rotateIn':
                    // 1文字ずつ回転して出現
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 2));
                            charAnimations.push({
                                opacity: charT,
                                rotation: (1 - charT) * 360,
                                scale: 0.5 + charT * 0.5,
                                offsetX: 0,
                                offsetY: 0
                            });
                        }
                    }
                    break;
                case 'cursorReveal':
                    // カーソルが動いて文字を表示
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        const cursorPos = t * charCount;
                        for (let i = 0; i < charCount; i++) {
                            const visible = i < cursorPos;
                            const isCursor = Math.floor(cursorPos) === i;
                            charAnimations.push({
                                opacity: visible ? 1 : 0,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: 0,
                                showCursor: isCursor && t < 1
                            });
                        }
                    }
                    break;
                case 'zoomIn':
                    // ズームインしてドン！
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 1.5));
                            // バウンス効果
                            let scale = 1;
                            if (charT < 0.6) {
                                scale = 3 - charT * 3.33;  // 3 -> 1
                            } else if (charT < 0.8) {
                                scale = 1 + (charT - 0.6) * 1.5;  // 1 -> 1.3
                            } else {
                                scale = 1.3 - (charT - 0.8) * 1.5;  // 1.3 -> 1
                            }
                            charAnimations.push({
                                opacity: charT > 0 ? 1 : 0,
                                rotation: 0,
                                scale: scale,
                                offsetX: 0,
                                offsetY: 0
                            });
                        }
                    }
                    break;
                case 'splitMerge':
                    // 上下に分割して合体
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            const charT = Math.max(0, Math.min(1, (t * charCount - i) * 2));
                            const offset = (1 - charT) * 50;
                            charAnimations.push({
                                opacity: 1,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: 0,
                                splitTop: -offset,
                                splitBottom: offset
                            });
                        }
                    }
                    break;
                case 'slot':
                    // スロットのように縦スクロールして左から順番に止まる
                    if (obj.chars && charCount > 0) {
                        charAnimations = [];
                        for (let i = 0; i < charCount; i++) {
                            // 左の文字から順番に止まる（各文字に遅延）
                            const stopDelay = i * (0.8 / charCount);  // 全体の80%の時間で順番に止まる
                            const charT = Math.max(0, Math.min(1, (t - stopDelay) / (1 - stopDelay)));

                            // スクロール効果（上から下へ流れる）
                            let slotOffset = 0;
                            if (charT < 1) {
                                // 高速スクロール中
                                const scrollSpeed = 8;  // スクロール速度
                                const phase = (1 - charT) * scrollSpeed * Math.PI * 2;
                                // サイン波で上下にスクロール（上から下へ流れるように見える）
                                slotOffset = Math.sin(phase) * 30;

                                // 止まる直前は減速
                                if (charT > 0.7) {
                                    const slowdown = (charT - 0.7) / 0.3;
                                    slotOffset *= (1 - slowdown);
                                }
                            }

                            charAnimations.push({
                                opacity: 1,
                                rotation: 0,
                                scale: 1,
                                offsetX: 0,
                                offsetY: slotOffset,
                                slotEffect: true
                            });
                        }
                    }
                    break;
                case 'rollUp':
                    y = obj.y + canvas.height - t * (canvas.height * 2) * speed;
                    break;
                case 'rollLeft':
                    x = obj.x + canvas.width - t * (canvas.width * 2) * speed;
                    break;
            }

            return { opacity, x, y, visibleChars, charAnimations };
        }

        // 連番PNGエクスポート
        async function exportSequencePNG() {
            const fps = parseInt(document.getElementById('exportFps').value) || 30;
            const duration = parseFloat(document.getElementById('exportDuration').value) || 3;
            const totalFrames = Math.ceil(fps * duration);

            // 状態を保存
            const wasPlaying = isPlaying;
            if (isPlaying) toggleAnimation();
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;
            exportingTransparent = document.getElementById('exportTransparent').checked;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;
            selectedObjIds = [];

            // 進捗表示
            const progress = document.createElement('div');
            progress.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:8px;z-index:10000;';
            progress.innerHTML = `<div>連番PNGエクスポート中...</div><div id="exportProgress">0/${totalFrames}</div>`;
            document.body.appendChild(progress);

            // ZIPファイルを作成（JSZipがなければ個別ダウンロード）
            const frames = [];

            for (let i = 0; i < totalFrames; i++) {
                animationTime = (i / fps);
                render();

                const dataUrl = canvas.toDataURL('image/png');
                const frameNum = String(i).padStart(5, '0');
                frames.push({ name: `frame_${frameNum}.png`, data: dataUrl });

                document.getElementById('exportProgress').textContent = `${i + 1}/${totalFrames}`;
                await new Promise(r => setTimeout(r, 10)); // UIを更新
            }

            // 各フレームをダウンロード
            if (frames.length <= 30) {
                // 30フレーム以下なら個別ダウンロード
                for (const frame of frames) {
                    const link = document.createElement('a');
                    link.download = frame.name;
                    link.href = frame.data;
                    link.click();
                    await new Promise(r => setTimeout(r, 100));
                }
            } else {
                // 多すぎる場合は警告
                alert(`${frames.length}フレームを生成しました。\nブラウザの制限により一括ダウンロードできません。\nFPSまたは時間を減らしてください。`);
            }

            // 状態を復元
            animationTime = 0;
            exportingTransparent = false;
            selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
            selectedObjIds = prevSelectedIds;
            safeMarginCheckbox.checked = wasEnabled;
            render();
            document.body.removeChild(progress);
        }

        // GIFエクスポート（簡易版）
        async function exportGIF() {
            const fps = parseInt(document.getElementById('exportFps').value) || 30;
            const duration = parseFloat(document.getElementById('exportDuration').value) || 3;
            const totalFrames = Math.ceil(fps * duration);

            // 状態を保存
            if (isPlaying) toggleAnimation();
            const safeMarginCheckbox = document.getElementById('safeMarginEnabled');
            const wasEnabled = safeMarginCheckbox.checked;
            safeMarginCheckbox.checked = false;
            exportingTransparent = document.getElementById('exportTransparent').checked;
            const prevSelectedIds = [...selectedObjIds];
            selectedObjId = null;
            selectedObjIds = [];

            // 進捗表示
            const progress = document.createElement('div');
            progress.style.cssText = 'position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);background:#333;color:#fff;padding:20px;border-radius:8px;z-index:10000;';
            progress.innerHTML = `<div>GIFエクスポート中...</div><div id="gifProgress">フレーム生成: 0/${totalFrames}</div>`;
            document.body.appendChild(progress);

            // 解像度を下げる（GIF用）
            const scale = Math.min(1, 640 / canvas.width);
            const gifWidth = Math.floor(canvas.width * scale);
            const gifHeight = Math.floor(canvas.height * scale);

            // 一時キャンバス
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = gifWidth;
            tempCanvas.height = gifHeight;
            const tempCtx = tempCanvas.getContext('2d');

            // フレームを収集
            const frames = [];
            for (let i = 0; i < totalFrames; i++) {
                animationTime = (i / fps);
                render();

                tempCtx.drawImage(canvas, 0, 0, gifWidth, gifHeight);
                const imageData = tempCtx.getImageData(0, 0, gifWidth, gifHeight);
                frames.push(imageData);

                document.getElementById('gifProgress').textContent = `フレーム生成: ${i + 1}/${totalFrames}`;
                await new Promise(r => setTimeout(r, 10));
            }

            // GIFエンコード
            document.getElementById('gifProgress').textContent = 'GIFエンコード中...';
            await new Promise(r => setTimeout(r, 100));

            try {
                const gif = encodeGIF(frames, gifWidth, gifHeight, Math.round(1000 / fps));

                // ダウンロード
                const blob = new Blob([gif], { type: 'image/gif' });
                const link = document.createElement('a');
                link.download = `telop_${Date.now()}.gif`;
                link.href = URL.createObjectURL(blob);
                link.click();
            } catch (e) {
                alert('GIFエンコードに失敗しました: ' + e.message);
            }

            // 状態を復元
            animationTime = 0;
            exportingTransparent = false;
            selectedObjId = prevSelectedIds.length > 0 ? prevSelectedIds[prevSelectedIds.length - 1] : null;
            selectedObjIds = prevSelectedIds;
            safeMarginCheckbox.checked = wasEnabled;
            render();
            document.body.removeChild(progress);
        }

        // 簡易GIFエンコーダー
        function encodeGIF(frames, width, height, delay) {
            const out = [];

            // GIF Header
            out.push(0x47, 0x49, 0x46, 0x38, 0x39, 0x61); // GIF89a

            // Logical Screen Descriptor
            out.push(width & 0xFF, (width >> 8) & 0xFF);
            out.push(height & 0xFF, (height >> 8) & 0xFF);
            out.push(0xF7, 0x00, 0x00); // Global color table, 256 colors

            // Global Color Table (256 colors)
            for (let i = 0; i < 256; i++) {
                const r = (i >> 5) * 36;
                const g = ((i >> 2) & 7) * 36;
                const b = (i & 3) * 85;
                out.push(r, g, b);
            }

            // Netscape Extension for looping
            out.push(0x21, 0xFF, 0x0B);
            out.push(0x4E, 0x45, 0x54, 0x53, 0x43, 0x41, 0x50, 0x45, 0x32, 0x2E, 0x30); // NETSCAPE2.0
            out.push(0x03, 0x01, 0x00, 0x00, 0x00);

            // Frames
            for (const frame of frames) {
                // Graphic Control Extension
                out.push(0x21, 0xF9, 0x04);
                out.push(0x04); // Disposal: restore to background
                out.push((delay / 10) & 0xFF, ((delay / 10) >> 8) & 0xFF);
                out.push(0x00, 0x00);

                // Image Descriptor
                out.push(0x2C);
                out.push(0x00, 0x00, 0x00, 0x00); // Position
                out.push(width & 0xFF, (width >> 8) & 0xFF);
                out.push(height & 0xFF, (height >> 8) & 0xFF);
                out.push(0x00); // No local color table

                // Image Data (LZW compressed)
                const pixels = [];
                for (let i = 0; i < frame.data.length; i += 4) {
                    const r = frame.data[i];
                    const g = frame.data[i + 1];
                    const b = frame.data[i + 2];
                    // Convert to 8-bit palette index
                    const index = ((r >> 5) << 5) | ((g >> 5) << 2) | (b >> 6);
                    pixels.push(index);
                }

                // LZW encode
                const lzwData = lzwEncode(pixels, 8);
                out.push(8); // LZW minimum code size

                // Output in sub-blocks
                let pos = 0;
                while (pos < lzwData.length) {
                    const size = Math.min(255, lzwData.length - pos);
                    out.push(size);
                    for (let i = 0; i < size; i++) {
                        out.push(lzwData[pos++]);
                    }
                }
                out.push(0x00); // Block terminator
            }

            // Trailer
            out.push(0x3B);

            return new Uint8Array(out);
        }

        // LZW圧縮
        function lzwEncode(pixels, minCodeSize) {
            const clearCode = 1 << minCodeSize;
            const eoiCode = clearCode + 1;
            let codeSize = minCodeSize + 1;
            let nextCode = eoiCode + 1;
            const maxCode = 4095;

            const dict = new Map();
            for (let i = 0; i < clearCode; i++) {
                dict.set(String.fromCharCode(i), i);
            }

            const out = [];
            let bits = 0;
            let bitCount = 0;

            function writeBits(code) {
                bits |= (code << bitCount);
                bitCount += codeSize;
                while (bitCount >= 8) {
                    out.push(bits & 0xFF);
                    bits >>= 8;
                    bitCount -= 8;
                }
            }

            writeBits(clearCode);

            let current = String.fromCharCode(pixels[0]);
            for (let i = 1; i < pixels.length; i++) {
                const c = String.fromCharCode(pixels[i]);
                const combined = current + c;

                if (dict.has(combined)) {
                    current = combined;
                } else {
                    writeBits(dict.get(current));

                    if (nextCode <= maxCode) {
                        dict.set(combined, nextCode++);
                        if (nextCode > (1 << codeSize) && codeSize < 12) {
                            codeSize++;
                        }
                    }

                    current = c;
                }
            }

            writeBits(dict.get(current));
            writeBits(eoiCode);

            if (bitCount > 0) {
                out.push(bits & 0xFF);
            }

            return out;
        }

        function saveProject() {
            // 現在のキャンバスを保存
            saveCurrentCanvas();

            const project = {
                version: '3.0',
                canvases: canvases,
                activeCanvasId: activeCanvasId
            };
            const blob = new Blob([JSON.stringify(project)], { type: 'application/json' });
            const link = document.createElement('a');
            link.download = `telop_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        }

        function loadProject() { document.getElementById('fileInput').click(); }

        // PRSL読み込み機能
        let loadedPRSLStyles = [];
        let selectedPRSLIndex = -1;

        function importPRSL() { document.getElementById('prslInput').click(); }

        function handlePRSLLoad(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    // UTF-16 LEからテキストに変換
                    const arrayBuffer = ev.target.result;
                    const decoder = new TextDecoder('utf-16le');
                    let xmlText = decoder.decode(arrayBuffer);

                    // BOMを除去
                    if (xmlText.charCodeAt(0) === 0xFEFF) {
                        xmlText = xmlText.substring(1);
                    }

                    // XMLをパース
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');

                    // スタイルブロックを抽出
                    const styleBlocks = xmlDoc.querySelectorAll('styleblock');
                    loadedPRSLStyles = [];

                    styleBlocks.forEach(block => {
                        const style = parsePRSLStyle(block);
                        if (style) loadedPRSLStyles.push(style);
                    });

                    // UIにスタイル一覧を表示
                    selectedPRSLIndex = -1;
                    displayPRSLStyles();
                    document.getElementById('prslStatus').textContent = `${loadedPRSLStyles.length} スタイルを読み込みました`;
                } catch (err) {
                    document.getElementById('prslStatus').textContent = 'エラー: ' + err.message;
                    console.error(err);
                }
            };
            reader.readAsArrayBuffer(file);
            e.target.value = '';
        }

        function parsePRSLStyle(block) {
            const name = block.getAttribute('name') || 'Unknown';

            // フォント情報
            const fontFamily = block.querySelector('font > family')?.textContent || 'Yu Gothic UI';
            const fontSize = parseFloat(block.querySelector('text_specification > size')?.textContent) || 72;
            const fontStyle = block.querySelector('font > style')?.textContent || '';
            const isBold = fontStyle.toLowerCase().includes('bold') ||
                           block.querySelector('text_specification > bold')?.textContent === 'true';
            const isItalic = fontStyle.toLowerCase().includes('italic') ||
                             block.querySelector('text_specification > italic')?.textContent === 'true';

            // 字間・行間・その他
            const tracking = parseFloat(block.querySelector('text_specification > tracking')?.textContent) || 0;
            const leading = parseFloat(block.querySelector('text_specification > leading')?.textContent) || 0;
            const slant = parseFloat(block.querySelector('text_specification > slant')?.textContent) || 0;
            const scaleX = parseFloat(block.querySelector('text_specification > aspect')?.textContent) || 100;

            // ヘルパー関数: RGBAカラーを抽出
            function extractColor(elem) {
                if (!elem) return null;
                const r = Math.round((parseFloat(elem.querySelector('red')?.textContent) || 0) * 255);
                const g = Math.round((parseFloat(elem.querySelector('green')?.textContent) || 0) * 255);
                const b = Math.round((parseFloat(elem.querySelector('blue')?.textContent) || 0) * 255);
                const a = parseFloat(elem.querySelector('alpha')?.textContent);
                return {
                    hex: `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`,
                    opacity: isNaN(a) ? 100 : Math.round(a * 100)
                };
            }

            // 塗り情報を取得
            let fillColor = '#ffffff';
            let fillOpacity = 100;
            let gradient = null;

            const colouring = block.querySelector('face > shader > colouring');
            if (colouring) {
                // four_colour_ramp（上下2色グラデーション）
                const fourColourRamp = colouring.querySelector('four_colour_ramp');
                if (fourColourRamp) {
                    // 上側の色（top_left）と下側の色（bottom_left）を取得
                    const topLeft = fourColourRamp.querySelector('top_left');
                    const bottomLeft = fourColourRamp.querySelector('bottom_left');

                    const topColor = topLeft ? extractColor(topLeft) : null;
                    const bottomColor = bottomLeft ? extractColor(bottomLeft) : null;

                    if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                        gradient = {
                            type: 'linear',
                            angle: 90, // 上から下へ（90度 = 垂直方向）
                            stops: [
                                { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                            ]
                        };
                        fillColor = topColor.hex;
                    }
                }

                // two_colour_ramp（2色グラデーション）
                const twoColourRamp = colouring.querySelector('two_colour_ramp');
                if (!gradient && twoColourRamp) {
                    const top = twoColourRamp.querySelector('top');
                    const bottom = twoColourRamp.querySelector('bottom');

                    const topColor = top ? extractColor(top) : null;
                    const bottomColor = bottom ? extractColor(bottom) : null;

                    if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                        gradient = {
                            type: 'linear',
                            angle: 90, // 上から下へ（90度 = 垂直方向）
                            stops: [
                                { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                            ]
                        };
                        fillColor = topColor.hex;
                    }
                }

                // グラデーションチェック（linear_gradient）
                const linearGrad = colouring.querySelector('linear_gradient');
                if (linearGrad) {
                    const angle = parseFloat(linearGrad.querySelector('angle')?.textContent) || 0;
                    const stops = [];

                    // カラーストップを取得
                    linearGrad.querySelectorAll('stop').forEach(stop => {
                        const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                        const colorElem = stop.querySelector('all');
                        if (colorElem) {
                            const col = extractColor(colorElem);
                            stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                        }
                    });

                    // フォールバック: begin/end カラー
                    if (stops.length === 0) {
                        const beginColor = extractColor(linearGrad.querySelector('begin > all'));
                        const endColor = extractColor(linearGrad.querySelector('end > all'));
                        if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                        if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                    }

                    if (stops.length >= 2) {
                        gradient = {
                            type: 'linear',
                            angle: angle,
                            stops: stops
                        };
                        fillColor = stops[0].color;
                    }
                }

                // グラデーションチェック（radial_gradient / four_colour_gradient）
                const radialGrad = colouring.querySelector('radial_gradient, four_colour_gradient');
                if (!gradient && radialGrad) {
                    const stops = [];
                    radialGrad.querySelectorAll('stop').forEach(stop => {
                        const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                        const colorElem = stop.querySelector('all');
                        if (colorElem) {
                            const col = extractColor(colorElem);
                            stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                        }
                    });

                    // フォールバック: begin/end カラー
                    if (stops.length === 0) {
                        const beginColor = extractColor(radialGrad.querySelector('begin > all'));
                        const endColor = extractColor(radialGrad.querySelector('end > all'));
                        if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                        if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                    }

                    if (stops.length >= 2) {
                        gradient = {
                            type: 'radial',
                            stops: stops
                        };
                        fillColor = stops[0].color;
                    }
                }

                // ソリッドカラー
                if (!gradient) {
                    const solidColour = colouring.querySelector('solid_colour > all');
                    if (solidColour) {
                        const col = extractColor(solidColour);
                        fillColor = col.hex;
                        fillOpacity = col.opacity;
                    }
                }
            }

            // ストローク（embellishment）- 複数対応
            const strokes = [];
            for (let i = 11; i >= 0; i--) {  // 外側から内側へ（描画順）
                const emb = block.querySelector(`embellishment__${i}, embellishment_${i}`);
                if (!emb) continue;
                const existence = emb.querySelector('existence')?.textContent;
                if (existence !== '3') continue;  // 3 = active

                const embColouring = emb.querySelector('shader > colouring');
                let strokeColor = '#000000';
                let strokeOpacity = 100;
                let strokeGradient = null;

                if (embColouring) {
                    // ストロークの four_colour_ramp
                    const embFourRamp = embColouring.querySelector('four_colour_ramp');
                    if (embFourRamp) {
                        const topLeft = embFourRamp.querySelector('top_left');
                        const bottomLeft = embFourRamp.querySelector('bottom_left');
                        const topColor = topLeft ? extractColor(topLeft) : null;
                        const bottomColor = bottomLeft ? extractColor(bottomLeft) : null;
                        if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                            strokeGradient = {
                                type: 'linear',
                                angle: 90,
                                stops: [
                                    { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                    { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                                ]
                            };
                            strokeColor = topColor.hex;
                        }
                    }

                    // ストロークの two_colour_ramp
                    const embTwoRamp = embColouring.querySelector('two_colour_ramp');
                    if (!strokeGradient && embTwoRamp) {
                        const top = embTwoRamp.querySelector('top');
                        const bottom = embTwoRamp.querySelector('bottom');
                        const topColor = top ? extractColor(top) : null;
                        const bottomColor = bottom ? extractColor(bottom) : null;
                        if (topColor && bottomColor && topColor.hex && bottomColor.hex) {
                            strokeGradient = {
                                type: 'linear',
                                angle: 90,
                                stops: [
                                    { position: 0, color: topColor.hex, opacity: topColor.opacity },
                                    { position: 1, color: bottomColor.hex, opacity: bottomColor.opacity }
                                ]
                            };
                            strokeColor = topColor.hex;
                        }
                    }

                    // ストロークのlinear_gradient
                    const embLinearGrad = embColouring.querySelector('linear_gradient');
                    if (!strokeGradient && embLinearGrad) {
                        const angle = parseFloat(embLinearGrad.querySelector('angle')?.textContent) || 0;
                        const stops = [];
                        embLinearGrad.querySelectorAll('stop').forEach(stop => {
                            const pos = parseFloat(stop.querySelector('position')?.textContent) || 0;
                            const colorElem = stop.querySelector('all');
                            if (colorElem) {
                                const col = extractColor(colorElem);
                                stops.push({ position: pos, color: col.hex, opacity: col.opacity });
                            }
                        });
                        if (stops.length === 0) {
                            const beginColor = extractColor(embLinearGrad.querySelector('begin > all'));
                            const endColor = extractColor(embLinearGrad.querySelector('end > all'));
                            if (beginColor) stops.push({ position: 0, color: beginColor.hex, opacity: beginColor.opacity });
                            if (endColor) stops.push({ position: 1, color: endColor.hex, opacity: endColor.opacity });
                        }
                        if (stops.length >= 2) {
                            strokeGradient = { type: 'linear', angle: angle, stops: stops };
                            strokeColor = stops[0].color;
                        }
                    }

                    // ソリッドカラー
                    if (!strokeGradient) {
                        const embSolid = embColouring.querySelector('solid_colour > all');
                        if (embSolid) {
                            const col = extractColor(embSolid);
                            strokeColor = col.hex;
                            strokeOpacity = col.opacity;
                        }
                    }
                }

                const width = parseFloat(emb.querySelector('geometry > edge > size')?.textContent) || 20;
                strokes.push({
                    color: strokeColor,
                    width: Math.max(1, Math.round(width / 10)),  // PRSLは10倍スケール
                    opacity: strokeOpacity,
                    gradient: strokeGradient
                });
            }

            // シャドウ
            let shadow = null;
            const shadowElem = block.querySelector('face > shader > shadow');
            if (shadowElem && shadowElem.querySelector('on')?.textContent === 'true') {
                const shadowColour = shadowElem.querySelector('colour');
                if (shadowColour) {
                    const col = extractColor(shadowColour);
                    const distance = parseFloat(shadowElem.querySelector('distance')?.textContent) || 5;
                    const angle = parseFloat(shadowElem.querySelector('angle')?.textContent) || 135;
                    const blur = parseFloat(shadowElem.querySelector('blur')?.textContent) || 0;
                    shadow = {
                        color: col.hex,
                        opacity: col.opacity,
                        distance: distance,
                        angle: angle,
                        blur: blur
                    };
                }
            }

            // 光沢（sheen）
            const sheen = block.querySelector('face > shader > sheen');
            let gloss = null;
            if (sheen && sheen.querySelector('on')?.textContent === 'true') {
                const sheenColour = sheen.querySelector('colour');
                if (sheenColour) {
                    const col = extractColor(sheenColour);
                    gloss = {
                        color: col.hex,
                        opacity: col.opacity,
                        size: parseFloat(sheen.querySelector('size')?.textContent) || 50
                    };
                }
            }

            return { name, fontFamily, fontSize, isBold, isItalic, tracking, leading, slant, scaleX, fillColor, fillOpacity, gradient, strokes, shadow, gloss };
        }

        function displayPRSLStyles() {
            const list = document.getElementById('prslStyleList');
            list.innerHTML = '';

            // グリッドレイアウトで表示
            list.style.cssText = 'display:grid;grid-template-columns:repeat(auto-fill,minmax(80px,1fr));gap:4px;max-height:300px;overflow-y:auto;margin-top:8px;padding:4px;';

            loadedPRSLStyles.forEach((style, i) => {
                const container = document.createElement('div');
                container.style.cssText = 'cursor:pointer;border:2px solid #444;border-radius:3px;overflow:hidden;transition:border-color 0.2s;';
                container.title = `${style.name}\n${style.fontFamily} ${style.fontSize}pt`;
                container.onclick = () => applyPRSLStyle(i);
                container.onmouseenter = () => container.style.borderColor = '#0078d4';
                container.onmouseleave = () => container.style.borderColor = '#444';

                // Canvasでプレビューを描画
                const canvas = document.createElement('canvas');
                canvas.width = 80;
                canvas.height = 60;
                const ctx = canvas.getContext('2d');

                // チェッカーボード背景（透明表示用）
                const checkerSize = 8;
                for (let cy = 0; cy < canvas.height; cy += checkerSize) {
                    for (let cx = 0; cx < canvas.width; cx += checkerSize) {
                        ctx.fillStyle = ((cx + cy) / checkerSize) % 2 === 0 ? '#555' : '#777';
                        ctx.fillRect(cx, cy, checkerSize, checkerSize);
                    }
                }

                // テキスト描画設定
                const previewFontSize = 24;
                const text = 'あa';
                const fontWeight = style.isBold ? 'bold' : 'normal';
                const fontStyleStr = style.isItalic ? 'italic' : 'normal';
                ctx.font = `${fontStyleStr} ${fontWeight} ${previewFontSize}px "${style.fontFamily}", "Yu Gothic UI", sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                const x = canvas.width / 2;
                const y = canvas.height / 2;

                // オフスクリーンキャンバスでテキストを描画（光沢用）
                const offCanvas = document.createElement('canvas');
                offCanvas.width = canvas.width;
                offCanvas.height = canvas.height;
                const offCtx = offCanvas.getContext('2d');
                offCtx.font = ctx.font;
                offCtx.textAlign = 'center';
                offCtx.textBaseline = 'middle';

                // シャドウ描画（メインキャンバスに直接）
                if (style.shadow) {
                    const rad = (style.shadow.angle - 90) * Math.PI / 180;
                    const dist = style.shadow.distance * 0.4;
                    ctx.save();
                    ctx.shadowColor = style.shadow.color;
                    ctx.shadowBlur = style.shadow.blur * 0.5;
                    ctx.shadowOffsetX = Math.cos(rad) * dist;
                    ctx.shadowOffsetY = Math.sin(rad) * dist;
                    ctx.globalAlpha = style.shadow.opacity / 100;
                    ctx.fillStyle = style.shadow.color;
                    ctx.fillText(text, x, y);
                    ctx.restore();
                }

                // ストローク描画（外側から内側へ）
                style.strokes.forEach(stroke => {
                    ctx.save();
                    offCtx.save();
                    ctx.globalAlpha = stroke.opacity / 100;

                    if (stroke.gradient && stroke.gradient.stops.length >= 2) {
                        const grad = createPreviewGradient(ctx, stroke.gradient, x, y - previewFontSize/2, previewFontSize);
                        ctx.strokeStyle = grad;
                        offCtx.strokeStyle = grad;
                    } else {
                        ctx.strokeStyle = stroke.color;
                        offCtx.strokeStyle = stroke.color;
                    }

                    ctx.lineWidth = stroke.width * 0.6;
                    ctx.lineJoin = 'round';
                    ctx.strokeText(text, x, y);
                    offCtx.lineWidth = stroke.width * 0.6;
                    offCtx.lineJoin = 'round';
                    offCtx.strokeText(text, x, y);
                    ctx.restore();
                    offCtx.restore();
                });

                // 塗り描画
                ctx.save();
                offCtx.save();
                ctx.globalAlpha = (style.fillOpacity || 100) / 100;

                if (style.gradient && style.gradient.stops.length >= 2) {
                    const grad = createPreviewGradient(ctx, style.gradient, x, y - previewFontSize/2, previewFontSize);
                    ctx.fillStyle = grad;
                    offCtx.fillStyle = grad;
                } else {
                    ctx.fillStyle = style.fillColor;
                    offCtx.fillStyle = style.fillColor;
                }

                ctx.fillText(text, x, y);
                offCtx.fillText(text, x, y);
                ctx.restore();
                offCtx.restore();

                // 光沢描画（横一線バンド＋ぼかし）
                if (style.gloss) {
                    // Parse color
                    const glossCol = style.gloss.color;
                    const gr = parseInt(glossCol.slice(1, 3), 16);
                    const gg = parseInt(glossCol.slice(3, 5), 16);
                    const gb = parseInt(glossCol.slice(5, 7), 16);
                    const glossOpacity = style.gloss.opacity / 100;

                    // サイズから幅とぼかしを計算
                    const glossWidth = Math.max(2, style.gloss.size * 0.15);
                    const glossBlurSize = Math.max(1, style.gloss.size * 0.1);
                    const totalHeight = glossWidth + glossBlurSize * 2;

                    // 光沢バンドの位置（文字の中央よりやや上）
                    const glossY = y - previewFontSize * 0.05;

                    // オフスクリーンキャンバスで光沢を適用
                    offCtx.save();
                    offCtx.globalCompositeOperation = 'source-atop';

                    // グラデーションで上下にぼかし
                    const glossGrad = offCtx.createLinearGradient(0, glossY - totalHeight/2, 0, glossY + totalHeight/2);
                    glossGrad.addColorStop(0, `rgba(${gr},${gg},${gb},0)`);
                    const fadeRatio = glossBlurSize / totalHeight;
                    glossGrad.addColorStop(fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                    glossGrad.addColorStop(1 - fadeRatio, `rgba(${gr},${gg},${gb},${glossOpacity})`);
                    glossGrad.addColorStop(1, `rgba(${gr},${gg},${gb},0)`);

                    offCtx.fillStyle = glossGrad;
                    offCtx.fillRect(0, glossY - totalHeight/2, offCanvas.width, totalHeight);
                    offCtx.restore();

                    // メインキャンバスにオフスクリーンの結果を合成
                    ctx.drawImage(offCanvas, 0, 0);
                }

                container.appendChild(canvas);
                list.appendChild(container);
            });
        }

        // プレビュー用グラデーション生成
        function createPreviewGradient(ctx, gradientDef, x, y, height) {
            let grad;
            if (gradientDef.type === 'linear') {
                // 90度 = 垂直（上から下）で主レンダリングと一致
                const angle = (gradientDef.angle || 0) * Math.PI / 180;
                const len = height;
                const dx = Math.cos(angle) * len/2;
                const dy = Math.sin(angle) * len/2;
                grad = ctx.createLinearGradient(
                    x - dx, y + len/2 - dy,
                    x + dx, y + len/2 + dy
                );
            } else {
                grad = ctx.createRadialGradient(x, y + height/2, 0, x, y + height/2, height);
            }

            gradientDef.stops.forEach(stop => {
                grad.addColorStop(stop.position, stop.color);
            });

            return grad;
        }

        function applyPRSLStyle(index) {
            const statusEl = document.getElementById('prslStatus');
            if (!selectedObjId) {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }
            const obj = textObjects.find(o => o.id === selectedObjId);
            if (!obj || obj.type !== 'text') {
                if (statusEl) statusEl.textContent = 'テキストオブジェクトを選択してください';
                return;
            }

            const style = loadedPRSLStyles[index];
            if (!style) return;

            saveState();

            // 全文字にスタイルを適用
            obj.chars.forEach(c => {
                c.fontFamily = style.fontFamily;
                c.fontSize = style.fontSize;
                c.bold = style.isBold !== false;  // デフォルトはtrue
                c.italic = style.isItalic || false;
                c.opacity = style.fillOpacity || 100;
                c.tracking = style.tracking || 0;
                c.slant = style.slant || 0;
                c.scaleX = style.scaleX || 100;

                // グラデーション/塗り
                if (style.gradient && style.gradient.stops && style.gradient.stops.length >= 2) {
                    c.fillType = style.gradient.type;  // 'linear' or 'radial'
                    c.color = style.gradient.stops[0].color;
                    c.color2 = style.gradient.stops[style.gradient.stops.length - 1].color;
                    c.gradientAngle = style.gradient.angle || 0;
                    c.gradientBlur = 0;

                    // 中間ストップがある場合
                    if (style.gradient.stops.length > 2) {
                        c.gradientStops = style.gradient.stops.map(s => ({
                            color: s.color,
                            pos: s.position * 100,
                            endPos: s.position * 100
                        }));
                    } else {
                        c.gradientStops = [
                            { color: c.color, pos: 0, endPos: 0 },
                            { color: c.color2, pos: 100, endPos: 100 }
                        ];
                    }
                } else {
                    c.fillType = 'solid';
                    c.color = style.fillColor;
                    c.color2 = style.fillColor;
                    c.gradientStops = [
                        { color: style.fillColor, pos: 0, endPos: 0 },
                        { color: style.fillColor, pos: 100, endPos: 100 }
                    ];
                    c.gradientAngle = 0;
                    c.gradientBlur = 0;
                }

                // ストローク
                if (style.strokes && style.strokes.length > 0) {
                    c.strokes = style.strokes.map(s => {
                        const stroke = {
                            enabled: true,
                            type: 'edge',
                            color: s.color,
                            width: s.width,
                            opacity: s.opacity || 100,
                            angle: 45,
                            join: 'round'
                        };
                        // ストロークグラデーション
                        if (s.gradient && s.gradient.stops && s.gradient.stops.length >= 2) {
                            stroke.gradientEnabled = true;
                            stroke.gradientType = s.gradient.type;
                            stroke.color2 = s.gradient.stops[s.gradient.stops.length - 1].color;
                            stroke.gradientAngle = s.gradient.angle || 90;
                            stroke.gradientStops = s.gradient.stops.map(gs => ({
                                color: gs.color,
                                pos: gs.position * 100,
                                endPos: gs.position * 100
                            }));
                        }
                        return stroke;
                    });
                } else {
                    c.strokes = [];
                }

                // シャドウ（個別プロパティとして設定）
                if (style.shadow) {
                    c.shadowEnabled = true;
                    c.shadowColor = style.shadow.color;
                    c.shadowOpacity = style.shadow.opacity;
                    c.shadowDistance = style.shadow.distance;
                    c.shadowAngle = style.shadow.angle;
                    c.shadowBlur = style.shadow.blur;
                    c.shadowSize = 0;
                } else {
                    c.shadowEnabled = false;
                }

                // 光沢（個別プロパティとして設定）
                if (style.gloss) {
                    c.glossEnabled = true;
                    c.glossColor = style.gloss.color;
                    c.glossOpacity = style.gloss.opacity;
                    // PRSLのsizeからwidth/blurを計算
                    c.glossWidth = Math.max(5, style.gloss.size * 0.3);
                    c.glossBlur = Math.max(3, style.gloss.size * 0.2);
                } else {
                    c.glossEnabled = false;
                }
            });

            render();
            updateLayerProps();

            // 選択スタイルをハイライト
            selectedPRSLIndex = index;
            updatePRSLHighlight();

            // 成功メッセージ
            if (statusEl) statusEl.textContent = `スタイル「${style.name}」を適用しました`;
        }

        function updatePRSLHighlight() {
            const list = document.getElementById('prslStyleList');
            if (!list) return;
            Array.from(list.children).forEach((container, i) => {
                if (i === selectedPRSLIndex) {
                    container.style.borderColor = '#0078d4';
                    container.style.boxShadow = '0 0 5px rgba(0,120,212,0.5)';
                } else {
                    container.style.borderColor = '#444';
                    container.style.boxShadow = 'none';
                }
            });
        }

        function handleFileLoad(e) {
            const file = e.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const p = JSON.parse(ev.target.result);

                    // v3.0形式（複数キャンバス）
                    if (p.version === '3.0' && p.canvases) {
                        canvases = p.canvases;
                        activeCanvasId = p.activeCanvasId || canvases[0].id;
                        // オブジェクトのマイグレーション
                        canvases.forEach(canvasData => {
                            migrateObjects(canvasData.objects);
                        });
                        loadCurrentCanvas();
                        updateCanvasList();
                    }
                    // v2.x形式（単一キャンバス）- 後方互換性
                    else {
                        const imported = createCanvasData('キャンバス 1');
                        if (p.resolution) imported.resolution = p.resolution;
                        imported.objects = p.objects || [];
                        migrateObjects(imported.objects);
                        canvases = [imported];
                        activeCanvasId = imported.id;
                        loadCurrentCanvas();
                        updateCanvasList();
                    }

                    selectedObjId = null; selectedObjIds = []; editingObjId = null;
                    updateLayerList(); updateLayerProps(); render();
                } catch { alert('読込失敗'); }
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        // オブジェクトの後方互換性マイグレーション
        function migrateObjects(objects) {
            if (!objects) return;
            objects.forEach(obj => {
                if (!obj.name) obj.name = 'テキスト';
                if (!obj.textAlign) obj.textAlign = 'left';
                if (!obj.verticalAlign) obj.verticalAlign = 'middle';
                if (obj.opacity === undefined) obj.opacity = 100;
                if (obj.rotation === undefined) obj.rotation = 0;
                if (obj.lineHeight === undefined) obj.lineHeight = 1.2;
                // Initialize name tag properties
                if (!obj.nameTag) {
                    obj.nameTag = {
                        enabled: false, text: '', font: 'Yu Gothic UI', position: 'top-left', gap: 10,
                        color: '#ffffff', size: 36, bgEnabled: true, bgShape: 'rounded',
                        bgRadius: 5, bgColor: '#0078d4', bgOpacity: 100, padX: 10, padY: 5,
                        strokeEnabled: false, strokeColor: '#ffffff', strokeWidth: 2
                    };
                }
                if (obj.nameTag && !obj.nameTag.font) {
                    obj.nameTag.font = 'Yu Gothic UI';
                }
                // Initialize balloon properties
                if (!obj.balloon) {
                    obj.balloon = {
                        enabled: false, shape: 'rounded', radius: 20, padX: 30, padY: 20,
                        fill: '#ffffff', fillOpacity: 100, strokeEnabled: true,
                        strokeColor: '#000000', strokeWidth: 3, tailEnabled: true,
                        tailDir: 'bottom', tailPos: 50, tailWidth: 20, tailLength: 30
                    };
                }
                if (obj.chars) {
                    obj.chars.forEach(c => {
                        if (c.scaleX === undefined) c.scaleX = 100;
                        if (c.opacity === undefined) c.opacity = 100;
                        if (c.fillType === undefined) c.fillType = 'solid';
                        if (!c.strokes) c.strokes = [{ enabled: true, type: 'edge', color: '#000', width: 4, opacity: 100 }];
                    });
                }
            });
        }

        // 初期化
        initCanvases();
        render();
    </script>
</body>
</html>
